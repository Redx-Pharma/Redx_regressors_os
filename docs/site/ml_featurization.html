<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />


  <title>redxregressors.ml_featurization API documentation</title>
  <meta name="description" content="Module for generating features such as chemical fingerprints and descriptors and teh converison of c..." />


  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

  <style type="text/css">
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}
</style>
  <style type="text/css">
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/
</style>
  <style type="text/css">
  pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */
  </style>
  <style type="text/css">
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}
</style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>
<div id="container">




















  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3>Super-module</h3>
      <ul>
        <li class="mono"><a href="index.html">redxregressors</a></li>
      </ul>
    </li>
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>

  <ul>
    <li class="mono"><a href="#redxregressors.ml_featurization.log">log</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>

  <ul>
    <li class="mono"><a href="#redxregressors.ml_featurization.bitstring_to_bit_vect">bitstring_to_bit_vect</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.df_rows_to_list_of_bit_vect">df_rows_to_list_of_bit_vect</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.from_smiles_without_default_graph_feature_gen">from_smiles_without_default_graph_feature_gen</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.get_count_ecfp">get_count_ecfp</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.get_deberta_smiles_rep">get_deberta_smiles_rep</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.get_ecfp">get_ecfp</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.get_maccs">get_maccs</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.get_nlp_smiles_rep">get_nlp_smiles_rep</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.get_rdkit_descriptors">get_rdkit_descriptors</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.get_t5_smiles_rep">get_t5_smiles_rep</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.list_of_bitvects_to_list_of_lists">list_of_bitvects_to_list_of_lists</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.list_of_bitvects_to_numpy_arrays">list_of_bitvects_to_numpy_arrays</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.validate_smile">validate_smile</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.validate_smiles">validate_smiles</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.validate_smiles_and_get_ecfp">validate_smiles_and_get_ecfp</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#redxregressors.ml_featurization.CECFPConverter">CECFPConverter</a></span>


  <ul>
    <li class="mono"><a href="#redxregressors.ml_featurization.CECFPConverter.fit">fit</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.CECFPConverter.fit_transform">fit_transform</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.CECFPConverter.get_metadata_routing">get_metadata_routing</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.CECFPConverter.get_params">get_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.CECFPConverter.set_output">set_output</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.CECFPConverter.set_params">set_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.CECFPConverter.transform">transform</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#redxregressors.ml_featurization.ECFPConverter">ECFPConverter</a></span>


  <ul>
    <li class="mono"><a href="#redxregressors.ml_featurization.ECFPConverter.fit">fit</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.ECFPConverter.fit_transform">fit_transform</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.ECFPConverter.get_metadata_routing">get_metadata_routing</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.ECFPConverter.get_params">get_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.ECFPConverter.set_output">set_output</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.ECFPConverter.set_params">set_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.ECFPConverter.transform">transform</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#redxregressors.ml_featurization.GCN_featurize">GCN_featurize</a></span>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#redxregressors.ml_featurization.GetAttentiveFPFeatures">GetAttentiveFPFeatures</a></span>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#redxregressors.ml_featurization.MACCSConverter">MACCSConverter</a></span>


  <ul>
    <li class="mono"><a href="#redxregressors.ml_featurization.MACCSConverter.fit">fit</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.MACCSConverter.fit_transform">fit_transform</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.MACCSConverter.get_metadata_routing">get_metadata_routing</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.MACCSConverter.get_params">get_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.MACCSConverter.set_output">set_output</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.MACCSConverter.set_params">set_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.MACCSConverter.transform">transform</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#redxregressors.ml_featurization.NLPConverter">NLPConverter</a></span>


  <ul>
    <li class="mono"><a href="#redxregressors.ml_featurization.NLPConverter.fit">fit</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.NLPConverter.fit_transform">fit_transform</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.NLPConverter.get_metadata_routing">get_metadata_routing</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.NLPConverter.get_params">get_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.NLPConverter.set_output">set_output</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.NLPConverter.set_params">set_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.NLPConverter.transform">transform</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter">RDKitDescriptorsConverter</a></span>


  <ul>
    <li class="mono"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter.fit">fit</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter.fit_transform">fit_transform</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter.get_metadata_routing">get_metadata_routing</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter.get_params">get_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter.set_output">set_output</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter.set_params">set_params</a></li>
    <li class="mono"><a href="#redxregressors.ml_featurization.RDKitDescriptorsConverter.transform">transform</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

<article id="content">





  <header id="section-intro">
  <h1 class="title"><span class="name">redxregressors.ml_featurization</span> module</h1>
  <p>Module for generating features such as chemical fingerprints and descriptors and teh converison of common data types of those representations</p>

  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization" class="source">
    <div class="codehilite"><pre><span></span><span class="ch">#!/usr/bin.env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for generating features such as chemical fingerprints and descriptors and teh converison of common data types of those representations</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Self</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rdkit</span><span class="w"> </span><span class="kn">import</span> <span class="n">Chem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rdkit.Chem</span><span class="w"> </span><span class="kn">import</span> <span class="n">MACCSkeys</span><span class="p">,</span> <span class="n">AllChem</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rdkit.DataStructs</span><span class="w"> </span><span class="kn">import</span> <span class="n">cDataStructs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rdkit.Chem.Descriptors</span><span class="w"> </span><span class="kn">import</span> <span class="n">CalcMolDescriptors</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sentence_transformers</span><span class="w"> </span><span class="kn">import</span> <span class="n">SentenceTransformer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch_geometric.loader</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch_geometric.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">Data</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pysmiles</span><span class="w"> </span><span class="kn">import</span> <span class="n">read_smiles</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">redxregressors</span><span class="w"> </span><span class="kn">import</span> <span class="n">utilities</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">redxregressors.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">seed_worker</span><span class="p">,</span> <span class="n">seed_all</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">torch</span><span class="o">.</span><span class="n">use_deterministic_algorithms</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ECFPConverter</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a pipeline module class for converting SMILES strings to ECFP fingerprints. It can be directly built into a sklearn pipeline.</span>
<span class="sd">    For example:</span>
<span class="sd">    from sklearn.pipeline import Pipeline</span>
<span class="sd">    from sklearn.ensemble import RandomForestClassifier</span>
<span class="sd">    from redxregressors import featurization</span>
<span class="sd">    model = Pipeline([(&#39;smiles_converter&#39;, featurization.ECFPConverter()), (&#39;RF&#39;, RandomForestClassifier())])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smiles_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smiles&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initialising transformer...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span> <span class="o">=</span> <span class="n">hash_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span> <span class="o">=</span> <span class="n">smiles_col</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to ECFP representations .....&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_ecfp</span><span class="p">(</span>
                <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
                <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
                <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_ecfp</span><span class="p">(</span>
                <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span>
                <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
                <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CECFPConverter</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a pipeline module class for converting SMILES strings to count ECFP fingerprints. It can be directly built into a sklearn pipeline.</span>
<span class="sd">    For example:</span>
<span class="sd">    from sklearn.pipeline import Pipeline</span>
<span class="sd">    from sklearn.preprocessing import StandardScaler</span>
<span class="sd">    from sklearn.ensemble import RandomForestClassifier</span>
<span class="sd">    from redxregressors import featurization</span>
<span class="sd">    model = Pipeline([(&#39;smiles_converter&#39;, featurization.CECFPConverter()), (&#39;scaler&#39;, StandardScaler()), (&#39;RF&#39;, RandomForestClassifier())])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smiles_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smiles&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initialising transformer...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span> <span class="o">=</span> <span class="n">hash_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span> <span class="o">=</span> <span class="n">smiles_col</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to CECFP representations .....&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_count_ecfp</span><span class="p">(</span>
                <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
                <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
                <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_count_ecfp</span><span class="p">(</span>
                <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span>
                <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
                <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MACCSConverter</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a pipeline module class for converting SMILES strings to MACCS fingerprints. It can be directly built into a sklearn pipeline.</span>
<span class="sd">    For example:</span>
<span class="sd">    from sklearn.pipeline import Pipeline</span>
<span class="sd">    from sklearn.ensemble import RandomForestClassifier</span>
<span class="sd">    from redxregressors import featurization</span>
<span class="sd">    model = Pipeline([(&#39;smiles_converter&#39;, featurization.MACCSConverter()), (&#39;RF&#39;, RandomForestClassifier())])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smiles_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smiles&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initialising transformer...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span> <span class="o">=</span> <span class="n">smiles_col</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to MACCS representations .....&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_maccs</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_maccs</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>


<span class="k">class</span><span class="w"> </span><span class="nc">RDKitDescriptorsConverter</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a pipeline module class for converting SMILES strings to RDKit descriptors. It can be directly built into a sklearn pipeline.</span>
<span class="sd">    For example:</span>
<span class="sd">    from sklearn.pipeline import Pipeline</span>
<span class="sd">    from sklearn.preprocessing import StandardScaler</span>
<span class="sd">    from sklearn.ensemble import RandomForestClassifier</span>
<span class="sd">    from redxregressors import featurization</span>
<span class="sd">    model = Pipeline([(&#39;smiles_converter&#39;, featurization.RDKitDescriptorsConverter()), (&#39;scaler&#39;, StandardScaler()), (&#39;RF&#39;, RandomForestClassifier())])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smiles_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smiles&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initialising transformer...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span> <span class="o">=</span> <span class="n">smiles_col</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to RDKit descriptors .....&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_rdkit_descriptors</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">get_rdkit_descriptors</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fps</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NLPConverter</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a pipeline module class for converting SMILES strings to sentence embeddings. It can be directly built into a sklearn pipeline.</span>
<span class="sd">    For example:</span>
<span class="sd">    from sklearn.pipeline import Pipeline</span>
<span class="sd">    from sklearn.preprocessing import StandardScaler</span>
<span class="sd">    from sklearn.ensemble import RandomForestClassifier</span>
<span class="sd">    from redxregressors import featurization</span>
<span class="sd">    model = Pipeline([(&#39;smiles_converter&#39;, featurization.NLPConverter()), (&#39;scaler&#39;, StandardScaler()), (&#39;RF&#39;, RandomForestClassifier())])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;laituan245/molt5-large-smiles2caption&quot;</span><span class="p">,</span>
        <span class="n">smiles_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smiles&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initialising transformer...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span> <span class="o">=</span> <span class="n">smiles_col</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">SentenceTransformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to sentence embeddings .....&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">embeddings</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span><span class="n">model_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span> <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">embeddings</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">embeddings</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span>
                <span class="n">model_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span> <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">embeddings</span>


<span class="k">def</span><span class="w"> </span><span class="nf">validate_smile</span><span class="p">(</span><span class="n">smile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">canonicalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to validate a single smiles string. This differs from get_valid_smiles as</span>
<span class="sd">    it operates on a single smiles string and garuntees a return as if the smiles is invalid it returns None.</span>

<span class="sd">    Args:</span>
<span class="sd">        smile (str): smiles string to check if it is valid</span>
<span class="sd">        canaonicalize (bool): whether to return the input smiles or a canonicalized version for a valid smiles string</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[None, str]: None for a invalid smiles string and a smiles string for a valid one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smile</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Exception when converting smiles to RDKit molecule object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SMILES string: </span><span class="si">{</span><span class="n">smile</span><span class="si">}</span><span class="s2"> is invalid in RDKit and will be skipped&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">canonicalize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">smile</span>


<span class="k">def</span><span class="w"> </span><span class="nf">validate_smiles</span><span class="p">(</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">return_failed_as_None</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">canonicalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to validate a list of m smiles strings. This differs from get_valid_smiles as</span>
<span class="sd">    it can guarntee a return, if return_failed_as_None is True (defualt), as if the smiles</span>
<span class="sd">    is invalid it returns None.</span>

<span class="sd">    Args:</span>
<span class="sd">        smile (str): smiles string to check if it is valid</span>
<span class="sd">        return_failed_as_None (bool): whether to return None if the smiles string is invalid</span>
<span class="sd">        canaonicalize (bool): whether to return the input smiles or a canonicalized version for a valid smiles string</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[Union[None, str]]: None for a invalid smiles string and a smiles string for a valid one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">return_failed_as_None</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">validate_smile</span><span class="p">(</span><span class="n">smile</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="n">canonicalize</span><span class="p">)</span> <span class="k">for</span> <span class="n">smile</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">validate_smile</span><span class="p">(</span><span class="n">smile</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="n">canonicalize</span><span class="p">)</span> <span class="k">for</span> <span class="n">smile</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ent</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">list_of_bitvects_to_numpy_arrays</span><span class="p">(</span>
    <span class="n">bvs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to convert list of explicit bitvectirs from RDKit to numpy arrays. Note that at the time of writing RDKit has functions to do this one at a time but not in batches.</span>

<span class="sd">    Args:</span>
<span class="sd">        bvs (List[cDataStructs.ExplicitBitVect]): List of bitvects from RDKit</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Numpy array of the bit vector arrays</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; list_of_bitvects_to_numpy_arrays([cDataStructs.CreateFromBitString(&quot;1011&quot;)]) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    array([[1, 0, 1, 1]], dtype=uint8)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">ToBitString</span><span class="p">())]</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">bvs</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">list_of_bitvects_to_list_of_lists</span><span class="p">(</span>
    <span class="n">bvs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to convert list of explicit bitvects from RDKit to list of lists. Note that at the time of writing RDKit has functions to do this one at a time but not in batches.</span>

<span class="sd">    Args:</span>
<span class="sd">        bvs (List[cDataStructs.ExplicitBitVect]): List of bitvects from RDKit</span>

<span class="sd">    Returns:</span>
<span class="sd">       List[List[int]]: list of lists of integer binary values</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; list_of_bitvects_to_list_of_lists([cDataStructs.CreateFromBitString(&quot;1011&quot;)]) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    [[1, 0, 1, 1]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">ToBitString</span><span class="p">())]</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">bvs</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">bitstring_to_bit_vect</span><span class="p">(</span><span class="n">bstring</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to convert a bit string i.e. &quot;100010101&quot; to an RDKit explicit bit vector</span>

<span class="sd">    Args:</span>
<span class="sd">        bstring (str): bit string i.e. a string made up of 1 and 0 only</span>

<span class="sd">    Returns:</span>
<span class="sd">        cDataStructs.ExplicitBitVect: RDKit explicit bit vector</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; bitstring_to_bit_vect(&#39;10101010001101&#39;) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    &lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cDataStructs</span><span class="o">.</span><span class="n">CreateFromBitString</span><span class="p">(</span><span class="n">bstring</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">df_rows_to_list_of_bit_vect</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert rows of binary values in a dataframe to a list of RDKit explicit bit vectors</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[cDataStructs.ExplicitBitVect]: _description_</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; df_rows_to_list_of_bit_vect(pd.DataFrame([[1, 0, 1, 0, 1, 1, 1, 1]])) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    [&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bitvectors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">to_list</span><span class="p">()])</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
        <span class="n">bitvectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bitstring_to_bit_vect</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">bitvectors</span>


<span class="k">def</span><span class="w"> </span><span class="nf">validate_smiles_and_get_ecfp</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate ECFP representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.</span>
<span class="sd">        hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; validate_smiles_and_get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    [&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]</span>

<span class="sd">    &gt; validate_smiles_and_get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    array([[0, 0, 0, ..., 0, 0, 0]], dtype=uint8)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">input_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">validate_smiles</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ECFP_smiles_standardized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">smiles</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ECFP_smiles_standardized&quot;</span><span class="p">])</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ECFP_smiles_standardized&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">input_n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">100.0</span><span class="si">}</span><span class="s2">% (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">input_n</span><span class="si">}</span><span class="s2">) of the input smiles were successfully read&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">validate_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">return_failed_as_None</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">input_n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">100.0</span><span class="si">}</span><span class="s2">% of the input smiles were successfully read&quot;</span>
        <span class="p">)</span>

    <span class="n">fp_gen</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganGenerator</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">fpSize</span><span class="o">=</span><span class="n">hash_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprintAsNumPy</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">smi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprintAsNumPy</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">smi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span>
            <span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ecfp_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hash_length</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprint</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">))</span> <span class="k">if</span> <span class="n">smi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">fps</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_ecfp</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate ECFP representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.</span>
<span class="sd">        hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Examples:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    (&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;,)</span>

<span class="sd">    &gt; get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    array([[0, 0, 0, ..., 0, 0, 0]], dtype=uint8)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making ECFP fingerprints for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>
    <span class="n">fp_gen</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganGenerator</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">fpSize</span><span class="o">=</span><span class="n">hash_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">list_of_bitvects_to_numpy_arrays</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_ll</span> <span class="o">=</span> <span class="n">list_of_bitvects_to_list_of_lists</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">fps_ll</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ecfp_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hash_length</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_count_ecfp</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">UIntSparseIntVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Function to generate count ECFP representations from smiles</span>

<span class="sd">     Args:</span>
<span class="sd">         data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">          If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">         smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">         smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">         radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.</span>
<span class="sd">         hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.</span>
<span class="sd">         return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">         return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">     Raises:</span>
<span class="sd">         RuntimeError: If incompatible inputs are given</span>

<span class="sd">     Returns:</span>
<span class="sd">         Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Examples:</span>
<span class="sd">    ```python</span>
<span class="sd">     &gt; get_count_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">     (&lt;rdkit.DataStructs.cDataStructs.UIntSparseIntVect object at ...&gt;,)</span>

<span class="sd">     &gt; get_count_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">     array([[0, 0, 0, ..., 0, 0, 0]])</span>
<span class="sd">     ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making CECFP fingerprints for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>
    <span class="n">fp_gen</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganGenerator</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">fpSize</span><span class="o">=</span><span class="n">hash_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetCountFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetCountFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_ll</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">]</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">fps_ll</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ecfp_count_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hash_length</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetCountFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_maccs</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate MACCS MDL keys representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Doctest:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; get_maccs(smiles=[&quot;c1ccccc1C&quot;]) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    [&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]</span>

<span class="sd">    &gt; get_maccs(smiles=[&quot;c1ccccc1C&quot;])[0].GetOnBits()</span>
<span class="sd">    (160, 162, 163, 165)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making MACCS fingerprints for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">MACCSkeys</span><span class="o">.</span><span class="n">GenMACCSKeys</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">num_maccs_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_ll</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">]</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">fps_ll</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;maccs_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_maccs_keys</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fps</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_rdkit_descriptors</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate Rdkit descriptor representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; type(get_rdkit_descriptors(smiles=[&quot;c1ccccc1C&quot;])[0])</span>
<span class="sd">    &lt;class &#39;dict&#39;&gt;</span>

<span class="sd">    &gt; len(get_rdkit_descriptors(smiles=[&quot;c1ccccc1C&quot;], return_df=True).columns)</span>
<span class="sd">    210</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making RDKit descriptors for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>

    <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">CalcMolDescriptors</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="c1"># make the order consistent sort on the keys in the dictionary important for the numpy return</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">fps_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;rdkit_descriptor_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fps_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fps</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_t5_smiles_rep</span><span class="p">(</span>
    <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;laituan245/molt5-large-smiles2caption&quot;</span><span class="p">,</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate the T5 embedding representations from smiles using a transformer model. We use the Apache - 2.0 licened model (accessed 7/10/24)</span>
<span class="sd">    from laituan245/molt5-large-smiles2caption https://huggingface.co/laituan245/molt5-large-smiles2caption. This function calls get_nlp_smiles_rep using this model.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_name (str): the model name to use,</span>
<span class="sd">        model_type (str): The model type to use i.e. bert, roberta or gpt2.</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>
<span class="sd">        combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is &quot;mean&quot;</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">embedding_rep</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span>
        <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
        <span class="n">data_df</span><span class="o">=</span><span class="n">data_df</span><span class="p">,</span>
        <span class="n">smiles_column</span><span class="o">=</span><span class="n">smiles_column</span><span class="p">,</span>
        <span class="n">smiles</span><span class="o">=</span><span class="n">smiles</span><span class="p">,</span>
        <span class="n">return_df</span><span class="o">=</span><span class="n">return_df</span><span class="p">,</span>
        <span class="n">return_np</span><span class="o">=</span><span class="n">return_np</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">embedding_rep</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_deberta_smiles_rep</span><span class="p">(</span>
    <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;knowledgator/SMILES-DeBERTa-large&quot;</span><span class="p">,</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate the DeBERTa embedding representations from smiles using a transformer model. We use the Apache - 2.0 licened model (accessed 7/10/24)</span>
<span class="sd">    from knowledgator/SMILES-DeBERTa-large https://huggingface.co/knowledgator/SMILES-DeBERTa-large. This function calls get_nlp_smiles_rep using this model.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_name (str): the model name to use,</span>
<span class="sd">        model_type (str): The model type to use i.e. bert, roberta or gpt2.</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>
<span class="sd">        combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is &quot;mean&quot;</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">embedding_rep</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span>
        <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
        <span class="n">data_df</span><span class="o">=</span><span class="n">data_df</span><span class="p">,</span>
        <span class="n">smiles_column</span><span class="o">=</span><span class="n">smiles_column</span><span class="p">,</span>
        <span class="n">smiles</span><span class="o">=</span><span class="n">smiles</span><span class="p">,</span>
        <span class="n">return_df</span><span class="o">=</span><span class="n">return_df</span><span class="p">,</span>
        <span class="n">return_np</span><span class="o">=</span><span class="n">return_np</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">embedding_rep</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_nlp_smiles_rep</span><span class="p">(</span>
    <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset&quot;</span><span class="p">,</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate the NLP embedding representations from smiles using a transformer model</span>

<span class="sd">    Args:</span>
<span class="sd">        model_name (str): the model name to use, default Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset apache 2.0 license accessed 30/10/24 https://huggingface.co/Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>
<span class="sd">        combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is &quot;mean&quot;</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">input_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>

    <span class="n">valid_smiles</span> <span class="o">=</span> <span class="n">validate_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">return_failed_as_None</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_smiles</span><span class="p">)</span> <span class="o">!=</span> <span class="n">input_n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;ERROR - only </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_smiles</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">input_n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">100.0</span><span class="si">}</span><span class="s2">% of the input smiles were successfully read. Please correct the invalid smiles&quot;</span>
        <span class="p">)</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Making NLP embeddings using model </span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span>
    <span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">SentenceTransformer</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">embedding_rep</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">embedding_rep</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">embedding_rep</span><span class="p">)</span>
        <span class="n">fps_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;embedding_</span><span class="si">{</span><span class="n">model_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fps_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">embedding_rep</span>


<span class="k">def</span><span class="w"> </span><span class="nf">from_smiles_without_default_graph_feature_gen</span><span class="p">(</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">validate_and_canonicalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Data</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts a SMILES string to a :class:`torch_geometric.data.Data`</span>
<span class="sd">    instance.</span>

<span class="sd">    Args:</span>
<span class="sd">        smiles (str): The SMILES string.</span>
<span class="sd">        with_hydrogen (bool, optional): If set to :obj:`True`, will store</span>
<span class="sd">            hydrogens in the molecule graph. (default: :obj:`False`)</span>
<span class="sd">        kekulize (bool, optional): If set to :obj:`True`, converts aromatic</span>
<span class="sd">            bonds to single/double bonds. (default: :obj:`False`)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">validate_and_canonicalize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">validate_smile</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">edge_index</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span>
        <span class="n">edge_attr</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
    <span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">smiles</span> <span class="o">=</span> <span class="n">smiles</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GetAttentiveFPFeatures</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for making the attentiveFP features. Its is based on the paper https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b00959 and the PyTorch Geometric documentation</span>
<span class="sd">    https://github.com/pyg-team/pytorch_geometric/blob/master/torch_geometric/datasets/molecule_net.py accessed 21/10/24. The pytorch geometric code is licensed under</span>
<span class="sd">    the MIT license which is given below.</span>
<span class="sd">    Copyright (c) 2023 PyG Team &lt;team@pyg.org&gt;</span>

<span class="sd">    Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="sd">    of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="sd">    in the Software without restriction, including without limitation the rights</span>
<span class="sd">    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="sd">    copies of the Software, and to permit persons to whom the Software is</span>
<span class="sd">    furnished to do so, subject to the following conditions:</span>

<span class="sd">    The above copyright notice and this permission notice shall be included in</span>
<span class="sd">    all copies or substantial portions of the Software.</span>

<span class="sd">    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="sd">    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="sd">    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="sd">    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="sd">    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="sd">    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="sd">    THE SOFTWARE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># these definitionns are based on the paper Pushing the Boundaries of Molecular Representation for Drug Discovery with the Graph Attention Mechanism and</span>
        <span class="c1"># the AttentiveFP model in pytorch geometric https://github.com/pyg-team/pytorch_geometric/blob/master/torch_geometric/datasets/molecule_net.py. The license</span>
        <span class="c1"># for the pytorch geometric code is given above but this class has been re-written for use here.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;B&quot;</span><span class="p">,</span>
            <span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="s2">&quot;N&quot;</span><span class="p">,</span>
            <span class="s2">&quot;O&quot;</span><span class="p">,</span>
            <span class="s2">&quot;F&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Si&quot;</span><span class="p">,</span>
            <span class="s2">&quot;P&quot;</span><span class="p">,</span>
            <span class="s2">&quot;S&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Cl&quot;</span><span class="p">,</span>
            <span class="s2">&quot;As&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Se&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Br&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Te&quot;</span><span class="p">,</span>
            <span class="s2">&quot;I&quot;</span><span class="p">,</span>
            <span class="s2">&quot;At&quot;</span><span class="p">,</span>
            <span class="s2">&quot;metal&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stereo_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREONONE</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOANY</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOZ</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOE</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hybrid_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">HybridizationType</span><span class="o">.</span><span class="n">SP</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">HybridizationType</span><span class="o">.</span><span class="n">SP2</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">HybridizationType</span><span class="o">.</span><span class="n">SP3</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">HybridizationType</span><span class="o">.</span><span class="n">SP3D</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">HybridizationType</span><span class="o">.</span><span class="n">SP3D2</span><span class="p">,</span>
            <span class="s2">&quot;other&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">TRIPLE</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">AROMATIC</span><span class="p">,</span>
        <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Data</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This functions produces the default AtteniveFP feature for nodes and edges in a graph from a SMILES string.</span>
<span class="sd">        See the paper Pushing the Boundaries of Molecular Representation for Drug Discovery with the Graph Attention Mechanism Table 1</span>
<span class="sd">        for the features used see the site https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b00959 for the paper.</span>
<span class="sd">        Args:</span>
<span class="sd">            data (Data): The data object to add the features to</span>
<span class="sd">        Returns:</span>
<span class="sd">            Data: The data object with the features added</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">validate_smile</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">smiles</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_mol</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">symbol_vec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">n_connections</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">hybridization_vec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hybrid_types</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">n_hydrogens</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">chiral_vec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">node_features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="c1"># symbol</span>
            <span class="n">sym_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">())</span>
            <span class="n">symbol_vec</span><span class="p">[</span><span class="n">sym_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># degree</span>
            <span class="n">n_con_idx</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetDegree</span><span class="p">()</span>
            <span class="n">n_connections</span><span class="p">[</span><span class="n">n_con_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># formal charge</span>
            <span class="n">formal_charge</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># radical electrons</span>
            <span class="n">radical_electrons</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span>
                <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">GetNumRadicalElectrons</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>

            <span class="c1"># hybridization</span>
            <span class="n">hyb_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hybrid_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetHybridization</span><span class="p">())</span>
            <span class="n">hybridization_vec</span><span class="p">[</span><span class="n">hyb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># aromaticity</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">():</span>
                <span class="n">aromaticity</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aromaticity</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># hydrogens</span>
            <span class="n">n_hyd_idx</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetTotalNumHs</span><span class="p">()</span>
            <span class="n">n_hydrogens</span><span class="p">[</span><span class="n">n_hyd_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># chirality</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_ChiralityPossible&quot;</span><span class="p">):</span>
                <span class="n">chirality</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chirality</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># chirality type</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                    <span class="n">chiral_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                    <span class="n">chiral_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="n">node_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">symbol_vec</span><span class="p">,</span>
                        <span class="n">n_connections</span><span class="p">,</span>
                        <span class="n">formal_charge</span><span class="p">,</span>
                        <span class="n">radical_electrons</span><span class="p">,</span>
                        <span class="n">hybridization_vec</span><span class="p">,</span>
                        <span class="n">aromaticity</span><span class="p">,</span>
                        <span class="n">n_hydrogens</span><span class="p">,</span>
                        <span class="n">chirality</span><span class="p">,</span>
                        <span class="n">chiral_vec</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">node_features</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">edge_indxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bond_order</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">stero_bond</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="c1"># graph index connections for the edges atom 1 to atom 2 and atom 2 to atom 1</span>
            <span class="n">edge_indxs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()])</span>
            <span class="n">edge_indxs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()])</span>

            <span class="c1"># bond type</span>
            <span class="n">bo_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">())</span>
            <span class="n">bond_order</span><span class="p">[</span><span class="n">bo_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># bond is it conjugated</span>
            <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetIsConjugated</span><span class="p">():</span>
                <span class="n">conjugation</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conjugation</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># is the bond in a ring</span>
            <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">IsInRing</span><span class="p">():</span>
                <span class="n">ring</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ring</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># bond stereo chemistry type if any</span>
            <span class="n">sb_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stereo_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">GetStereo</span><span class="p">())</span>
            <span class="n">stero_bond</span><span class="p">[</span><span class="n">sb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">bond_order</span><span class="p">,</span> <span class="n">conjugation</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">stero_bond</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

            <span class="n">edge_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_attr</span><span class="p">)</span>
            <span class="n">edge_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_attr</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_attrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">edge_indxs</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
            <span class="n">data</span><span class="o">.</span><span class="n">edge_attr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">edge_attrs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">() node_features: 39, edge_features: 10 Feature for AttentiveFP model https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b00959 table 1&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GCN_featurize</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to featurize molecules for use with a GCN model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">smiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">targets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">explicit_h</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_aromaticity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_charge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">elements</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">train_fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">test_fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">validation_fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class to featurize molecules for use with a GCN model.</span>
<span class="sd">        Args:</span>
<span class="sd">            smiles (list[str]): A list of SMILES strings.</span>
<span class="sd">            targets (list[float]): A list of target values.</span>
<span class="sd">            explicit_h (bool, optional): Whether to include explicit hydrogens. Defaults to True.</span>
<span class="sd">            include_aromaticity (bool, optional): Whether to include aromaticity. Defaults to True.</span>
<span class="sd">            include_charge (bool, optional): Whether to include charge. Defaults to True.</span>
<span class="sd">            elements (Optional[List[str]], optional): A list of elements to include. Defaults to None.</span>
<span class="sd">            train_fraction (Optional[float], optional): The fraction of data to use for training. Defaults to 0.8.</span>
<span class="sd">            test_fraction (Optional[float], optional): The fraction of data to use for testing. Defaults to 0.1.</span>
<span class="sd">            validation_fraction (Optional[float], optional): The fraction of data to use for validation. Defaults to 0.1.</span>
<span class="sd">            batch_size (Optional[int], optional): The batch size. Defaults to 1.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Self: The GCN_featurize object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smiles</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">validate_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="n">targets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">explicit_h</span> <span class="o">=</span> <span class="n">explicit_h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_aromaticity</span> <span class="o">=</span> <span class="n">include_aromaticity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_charge</span> <span class="o">=</span> <span class="n">include_charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_fraction</span> <span class="o">=</span> <span class="n">train_fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_fraction</span> <span class="o">=</span> <span class="n">test_fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validation_fraction</span> <span class="o">=</span> <span class="n">validation_fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>

        <span class="k">if</span> <span class="n">elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">explicit_h</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;H&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;B&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;C&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;N&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;O&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;F&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;P&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;S&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Cl&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Br&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;I&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;Cl&quot;</span><span class="p">,</span> <span class="s2">&quot;Br&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">elements</span>

        <span class="c1"># singe, aromatic, double, triple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataLoader</span> <span class="o">|</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DataLoader</span><span class="p">,</span> <span class="n">DataLoader</span><span class="p">,</span> <span class="n">DataLoader</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Featurize the molecules.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DataLoader | Tuple[DataLoader, DataLoader, DataLoader]: The data loader(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># seed all random number generators</span>
        <span class="n">seed_all</span><span class="p">()</span>

        <span class="c1"># to hold the data objects</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># determine which node featrues to include</span>
        <span class="n">node_vec_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_aromaticity</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">node_vec_length</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_charge</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">node_vec_length</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node features have length: </span><span class="si">{</span><span class="n">node_vec_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># iterate over the smiles and make the data objects</span>
        <span class="k">for</span> <span class="n">smi</span><span class="p">,</span> <span class="n">targ_y</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Cycling over smiles .....&quot;</span>
        <span class="p">):</span>
            <span class="n">molecule_features</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edge_idxs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edge_features</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># use the read_smiles function to get the graph with a key node features and edge features</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">read_smiles</span><span class="p">(</span><span class="n">smi</span><span class="p">,</span> <span class="n">explicit_hydrogen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">explicit_h</span><span class="p">)</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;element&quot;</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_aromaticity</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">aromatic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;aromatic&quot;</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_charge</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">charge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;charge&quot;</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># iterate over the nodes to make the node features. We build a vector for each node and aggregate them into a list as a molecule matrix for the node features</span>
            <span class="k">for</span> <span class="n">ith</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
                <span class="n">node_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">node_vec_length</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">node_vec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_aromaticity</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">node_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">aromatic</span><span class="p">[</span><span class="n">ith</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_charge</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">node_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge</span><span class="p">[</span><span class="n">ith</span><span class="p">]</span>
                <span class="n">molecule_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_vec</span><span class="p">)</span>

            <span class="c1"># iterate over the edges to make the edge features. We build a vector for each edge and aggregate them into a list as a molecule matrix for the edge features.</span>
            <span class="c1"># Note that each bond is included as two edges in the graph to make the graph undirected. This means that the edge features are also duplicated. This is a requirement for the pytorch geometric data object.</span>
            <span class="k">for</span> <span class="n">ith</span><span class="p">,</span> <span class="n">edg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                <span class="n">edge_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edg</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">edge_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edg</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot; edge is </span><span class="si">{</span><span class="n">edg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;order&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> which is index </span><span class="si">{</span><span class="p">[</span><span class="n">jth</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">jth</span><span class="p">,</span><span class="w"> </span><span class="n">ent</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">edg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;order&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ent</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-5</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> in bond types </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">edg_feat_vec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">edg</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;order&quot;</span><span class="p">])])</span>
                <span class="n">edge_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edg_feat_vec</span><span class="p">)</span>
                <span class="n">edge_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edg_feat_vec</span><span class="p">)</span>

            <span class="c1"># make the data object for the molecule</span>
            <span class="n">mol_nodes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">molecule_features</span><span class="p">)</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">edge_idxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
            <span class="n">edge_attibutes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">edge_features</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">targ_y</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Data</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mol_nodes</span><span class="p">,</span> <span class="n">edge_index</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="n">edge_attibutes</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># We now have the features for all molecules so we noe split the data into train, test and validation sets if the fractions are set alternatively we return the data as a single DataLoader</span>
        <span class="c1"># first the single dataloader case</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">ent</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_fraction</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">test_fraction</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">validation_fraction</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;At least one of train, test and validation fractions is None so returning the data as a single DataLoader. If you intend to split the data please set all the fractions 0.0 &quot;</span>
            <span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">()</span>
            <span class="n">g</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">DataLoader</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">worker_init_fn</span><span class="o">=</span><span class="n">seed_worker</span><span class="p">,</span>
                <span class="n">generator</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># now the case where we split the data to train, test and validation sets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Splitting data into train, test and validation sets&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_fraction</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_fraction</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">validation_fraction</span>
                <span class="o">!=</span> <span class="mf">1.0</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;ERROR - The train, test and validation fractions do not sum to 1.0&quot;</span>
                <span class="p">)</span>
            <span class="n">n_train</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_fraction</span><span class="p">)</span>
            <span class="n">n_test</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_fraction</span><span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ith</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))]</span>
            <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_train</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">train_indices</span><span class="p">)))</span>
            <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">test_indices</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_test</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">validation_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">train_indices</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">test_indices</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ent</span> <span class="ow">in</span> <span class="n">train_indices</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">test_indices</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;ERROR - The train and test sets have overlapping indices&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ent</span> <span class="ow">in</span> <span class="n">train_indices</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">validation_indices</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;ERROR - The train and validation sets have overlapping indices&quot;</span>
                <span class="p">)</span>

            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Splitting data into train, test and validation sets with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">train_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> data points for training, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> data points for testing and the rest &quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">validation_indices</span><span class="p">)</span><span class="si">}</span><span class="s2"> data points for validation.&quot;</span>
            <span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Train indices: </span><span class="si">{</span><span class="n">train_indices</span><span class="si">}{</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="si">}</span><span class="s2">Test indicies: </span><span class="si">{</span><span class="n">test_indices</span><span class="si">}{</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="si">}</span><span class="s2">Validation indicies: </span><span class="si">{</span><span class="n">validation_indices</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">()</span>
            <span class="n">g</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">train</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
                <span class="c1"># data[:train_stop_index],</span>
                <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">ith</span><span class="p">]</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="n">train_indices</span><span class="p">],</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">worker_init_fn</span><span class="o">=</span><span class="n">seed_worker</span><span class="p">,</span>
                <span class="n">generator</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
                <span class="c1"># data[train_stop_index:test_stop_index],</span>
                <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">ith</span><span class="p">]</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="n">test_indices</span><span class="p">],</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">worker_init_fn</span><span class="o">=</span><span class="n">seed_worker</span><span class="p">,</span>
                <span class="n">generator</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">validation</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
                <span class="c1"># data[test_stop_index:],</span>
                <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">ith</span><span class="p">]</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="n">validation_indices</span><span class="p">],</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">worker_init_fn</span><span class="o">=</span><span class="n">seed_worker</span><span class="p">,</span>
                <span class="n">generator</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">validation</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">doctest</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="redxregressors.ml_featurization.log" class="name">var <span class="ident">log</span></p>


  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>

  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.bitstring_to_bit_vect">
    <p>def <span class="ident">bitstring_to_bit_vect</span>(</p><p>bstring: str)</p>
    </div>




    <div class="desc"><p>Function to convert a bit string i.e. "100010101" to an RDKit explicit bit vector</p>
<p>Args:
    bstring (str): bit string i.e. a string made up of 1 and 0 only</p>
<p>Returns:
    cDataStructs.ExplicitBitVect: RDKit explicit bit vector</p>
<p>Doctest:</p>
<blockquote>
<p>bitstring_to_bit_vect('10101010001101') # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
<rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...></p>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.bitstring_to_bit_vect', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.bitstring_to_bit_vect" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">bitstring_to_bit_vect</span><span class="p">(</span><span class="n">bstring</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to convert a bit string i.e. &quot;100010101&quot; to an RDKit explicit bit vector</span>

<span class="sd">    Args:</span>
<span class="sd">        bstring (str): bit string i.e. a string made up of 1 and 0 only</span>

<span class="sd">    Returns:</span>
<span class="sd">        cDataStructs.ExplicitBitVect: RDKit explicit bit vector</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; bitstring_to_bit_vect(&#39;10101010001101&#39;) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    &lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cDataStructs</span><span class="o">.</span><span class="n">CreateFromBitString</span><span class="p">(</span><span class="n">bstring</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.df_rows_to_list_of_bit_vect">
    <p>def <span class="ident">df_rows_to_list_of_bit_vect</span>(</p><p>df: pandas.core.frame.DataFrame)</p>
    </div>




    <div class="desc"><p>Convert rows of binary values in a dataframe to a list of RDKit explicit bit vectors</p>
<p>Args:
    df (pd.DataFrame): <em>description</em></p>
<p>Returns:
    List[cDataStructs.ExplicitBitVect]: <em>description</em></p>
<p>Doctest:</p>
<blockquote>
<p>df_rows_to_list_of_bit_vect(pd.DataFrame([[1, 0, 1, 0, 1, 1, 1, 1]])) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
[<rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...>]</p>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.df_rows_to_list_of_bit_vect', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.df_rows_to_list_of_bit_vect" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">df_rows_to_list_of_bit_vect</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert rows of binary values in a dataframe to a list of RDKit explicit bit vectors</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[cDataStructs.ExplicitBitVect]: _description_</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; df_rows_to_list_of_bit_vect(pd.DataFrame([[1, 0, 1, 0, 1, 1, 1, 1]])) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    [&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bitvectors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">to_list</span><span class="p">()])</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
        <span class="n">bitvectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bitstring_to_bit_vect</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">bitvectors</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.from_smiles_without_default_graph_feature_gen">
    <p>def <span class="ident">from_smiles_without_default_graph_feature_gen</span>(</p><p>smiles: str, validate_and_canonicalize: bool = False)</p>
    </div>




    <div class="desc"><p>Converts a SMILES string to a :class:<code>torch_geometric.data.Data</code>
instance.</p>
<p>Args:
    smiles (str): The SMILES string.
    with_hydrogen (bool, optional): If set to :obj:<code>True</code>, will store
        hydrogens in the molecule graph. (default: :obj:<code>False</code>)
    kekulize (bool, optional): If set to :obj:<code>True</code>, converts aromatic
        bonds to single/double bonds. (default: :obj:<code>False</code>)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.from_smiles_without_default_graph_feature_gen', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.from_smiles_without_default_graph_feature_gen" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">from_smiles_without_default_graph_feature_gen</span><span class="p">(</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">validate_and_canonicalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Data</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts a SMILES string to a :class:`torch_geometric.data.Data`</span>
<span class="sd">    instance.</span>

<span class="sd">    Args:</span>
<span class="sd">        smiles (str): The SMILES string.</span>
<span class="sd">        with_hydrogen (bool, optional): If set to :obj:`True`, will store</span>
<span class="sd">            hydrogens in the molecule graph. (default: :obj:`False`)</span>
<span class="sd">        kekulize (bool, optional): If set to :obj:`True`, converts aromatic</span>
<span class="sd">            bonds to single/double bonds. (default: :obj:`False`)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">validate_and_canonicalize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">validate_smile</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">edge_index</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span>
        <span class="n">edge_attr</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
    <span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">smiles</span> <span class="o">=</span> <span class="n">smiles</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.get_count_ecfp">
    <p>def <span class="ident">get_count_ecfp</span>(</p><p>data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, radius: int = 2, hash_length: int = 2048, return_df: bool = False, return_np: bool = False, n_threads: int = 8, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate count ECFP representations from smiles</p>
<p>Args:
     data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
      If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
     smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
     smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
     radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.
     hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.
     return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
     return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</p>
<p>Raises:
     RuntimeError: If incompatible inputs are given</p>
<p>Returns:
     Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p>
<p>Examples:
```python</p>
<blockquote>
<p>get_count_ecfp(smiles=["c1ccccc1C"], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
 (<rdkit.DataStructs.cDataStructs.UIntSparseIntVect object at ...>,)</p>
<p>get_count_ecfp(smiles=["c1ccccc1C"], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
 array([[0, 0, 0, &hellip;, 0, 0, 0]])
 ```</p>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.get_count_ecfp', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.get_count_ecfp" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_count_ecfp</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">UIntSparseIntVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Function to generate count ECFP representations from smiles</span>

<span class="sd">     Args:</span>
<span class="sd">         data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">          If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">         smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">         smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">         radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.</span>
<span class="sd">         hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.</span>
<span class="sd">         return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">         return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">     Raises:</span>
<span class="sd">         RuntimeError: If incompatible inputs are given</span>

<span class="sd">     Returns:</span>
<span class="sd">         Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Examples:</span>
<span class="sd">    ```python</span>
<span class="sd">     &gt; get_count_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">     (&lt;rdkit.DataStructs.cDataStructs.UIntSparseIntVect object at ...&gt;,)</span>

<span class="sd">     &gt; get_count_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">     array([[0, 0, 0, ..., 0, 0, 0]])</span>
<span class="sd">     ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making CECFP fingerprints for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>
    <span class="n">fp_gen</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganGenerator</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">fpSize</span><span class="o">=</span><span class="n">hash_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetCountFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetCountFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_ll</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">]</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">fps_ll</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ecfp_count_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hash_length</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetCountFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.get_deberta_smiles_rep">
    <p>def <span class="ident">get_deberta_smiles_rep</span>(</p><p>model_name: str = &#39;knowledgator/SMILES-DeBERTa-large&#39;, data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, return_df: bool = False, return_np: bool = False, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate the DeBERTa embedding representations from smiles using a transformer model. We use the Apache - 2.0 licened model (accessed 7/10/24)
from knowledgator/SMILES-DeBERTa-large https://huggingface.co/knowledgator/SMILES-DeBERTa-large. This function calls get_nlp_smiles_rep using this model.</p>
<p>Args:
    model_name (str): the model name to use,
    model_type (str): The model type to use i.e. bert, roberta or gpt2.
    data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
     If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
    smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
    smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
    return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
    return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.
    combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is "mean"</p>
<p>Raises:
    RuntimeError: If incompatible inputs are given</p>
<p>Returns:
    Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.get_deberta_smiles_rep', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.get_deberta_smiles_rep" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_deberta_smiles_rep</span><span class="p">(</span>
    <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;knowledgator/SMILES-DeBERTa-large&quot;</span><span class="p">,</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate the DeBERTa embedding representations from smiles using a transformer model. We use the Apache - 2.0 licened model (accessed 7/10/24)</span>
<span class="sd">    from knowledgator/SMILES-DeBERTa-large https://huggingface.co/knowledgator/SMILES-DeBERTa-large. This function calls get_nlp_smiles_rep using this model.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_name (str): the model name to use,</span>
<span class="sd">        model_type (str): The model type to use i.e. bert, roberta or gpt2.</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>
<span class="sd">        combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is &quot;mean&quot;</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">embedding_rep</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span>
        <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
        <span class="n">data_df</span><span class="o">=</span><span class="n">data_df</span><span class="p">,</span>
        <span class="n">smiles_column</span><span class="o">=</span><span class="n">smiles_column</span><span class="p">,</span>
        <span class="n">smiles</span><span class="o">=</span><span class="n">smiles</span><span class="p">,</span>
        <span class="n">return_df</span><span class="o">=</span><span class="n">return_df</span><span class="p">,</span>
        <span class="n">return_np</span><span class="o">=</span><span class="n">return_np</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">embedding_rep</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.get_ecfp">
    <p>def <span class="ident">get_ecfp</span>(</p><p>data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, radius: int = 2, hash_length: int = 2048, return_df: bool = False, return_np: bool = False, n_threads: int = 8, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate ECFP representations from smiles</p>
<p>Args:
    data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
     If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
    smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
    smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
    radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.
    hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.
    return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
    return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</p>
<p>Raises:
    RuntimeError: If incompatible inputs are given</p>
<p>Returns:
    Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p>
<p>Examples:</p>
<pre><code class="language-python">&gt; get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
(&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;,)

&gt; get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
array([[0, 0, 0, ..., 0, 0, 0]], dtype=uint8)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.get_ecfp', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.get_ecfp" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_ecfp</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate ECFP representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.</span>
<span class="sd">        hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Examples:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    (&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;,)</span>

<span class="sd">    &gt; get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    array([[0, 0, 0, ..., 0, 0, 0]], dtype=uint8)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making ECFP fingerprints for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>
    <span class="n">fp_gen</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganGenerator</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">fpSize</span><span class="o">=</span><span class="n">hash_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">list_of_bitvects_to_numpy_arrays</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="n">fps_ll</span> <span class="o">=</span> <span class="n">list_of_bitvects_to_list_of_lists</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">fps_ll</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ecfp_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hash_length</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">],</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">n_threads</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.get_maccs">
    <p>def <span class="ident">get_maccs</span>(</p><p>data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, return_df: bool = False, return_np: bool = False, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate MACCS MDL keys representations from smiles</p>
<p>Args:
    data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
     If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
    smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
    smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
    return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
    return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</p>
<p>Raises:
    RuntimeError: If incompatible inputs are given</p>
<p>Returns:
    Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p>
<p>Doctest:</p>
<pre><code class="language-python">&gt; get_maccs(smiles=[&quot;c1ccccc1C&quot;]) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
[&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]

&gt; get_maccs(smiles=[&quot;c1ccccc1C&quot;])[0].GetOnBits()
(160, 162, 163, 165)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.get_maccs', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.get_maccs" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_maccs</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate MACCS MDL keys representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[Tuple[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Doctest:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; get_maccs(smiles=[&quot;c1ccccc1C&quot;]) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    [&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]</span>

<span class="sd">    &gt; get_maccs(smiles=[&quot;c1ccccc1C&quot;])[0].GetOnBits()</span>
<span class="sd">    (160, 162, 163, 165)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making MACCS fingerprints for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">MACCSkeys</span><span class="o">.</span><span class="n">GenMACCSKeys</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">num_maccs_keys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_ll</span> <span class="o">=</span> <span class="p">[</span><span class="n">ent</span><span class="o">.</span><span class="n">ToList</span><span class="p">()</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">]</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">fps_ll</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;maccs_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_maccs_keys</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.get_nlp_smiles_rep">
    <p>def <span class="ident">get_nlp_smiles_rep</span>(</p><p>model_name: str = &#39;Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset&#39;, data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, return_df: bool = False, return_np: bool = False, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate the NLP embedding representations from smiles using a transformer model</p>
<p>Args:
    model_name (str): the model name to use, default Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset apache 2.0 license accessed 30/10/24 https://huggingface.co/Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset
    data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
     If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
    smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
    smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
    return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
    return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.
    combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is "mean"</p>
<p>Raises:
    RuntimeError: If incompatible inputs are given</p>
<p>Returns:
    Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.get_nlp_smiles_rep', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.get_nlp_smiles_rep" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_nlp_smiles_rep</span><span class="p">(</span>
    <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset&quot;</span><span class="p">,</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate the NLP embedding representations from smiles using a transformer model</span>

<span class="sd">    Args:</span>
<span class="sd">        model_name (str): the model name to use, default Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset apache 2.0 license accessed 30/10/24 https://huggingface.co/Saideepthi55/sentencetransformer_ftmodel_on_chemical_dataset</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>
<span class="sd">        combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is &quot;mean&quot;</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">input_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>

    <span class="n">valid_smiles</span> <span class="o">=</span> <span class="n">validate_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">return_failed_as_None</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_smiles</span><span class="p">)</span> <span class="o">!=</span> <span class="n">input_n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;ERROR - only </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_smiles</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">input_n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">100.0</span><span class="si">}</span><span class="s2">% of the input smiles were successfully read. Please correct the invalid smiles&quot;</span>
        <span class="p">)</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Making NLP embeddings using model </span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span>
    <span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">SentenceTransformer</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">embedding_rep</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">embedding_rep</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">embedding_rep</span><span class="p">)</span>
        <span class="n">fps_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;embedding_</span><span class="si">{</span><span class="n">model_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fps_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">embedding_rep</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.get_rdkit_descriptors">
    <p>def <span class="ident">get_rdkit_descriptors</span>(</p><p>data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, return_df: bool = False, return_np: bool = False, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate Rdkit descriptor representations from smiles</p>
<p>Args:
    data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
     If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
    smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
    smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
    return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
    return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</p>
<p>Raises:
    RuntimeError: If incompatible inputs are given</p>
<p>Returns:
    Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p>
<p>Example:</p>
<pre><code class="language-python">&gt; type(get_rdkit_descriptors(smiles=[&quot;c1ccccc1C&quot;])[0])
&lt;class 'dict'&gt;

&gt; len(get_rdkit_descriptors(smiles=[&quot;c1ccccc1C&quot;], return_df=True).columns)
210
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.get_rdkit_descriptors', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.get_rdkit_descriptors" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_rdkit_descriptors</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate Rdkit descriptor representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; type(get_rdkit_descriptors(smiles=[&quot;c1ccccc1C&quot;])[0])</span>
<span class="sd">    &lt;class &#39;dict&#39;&gt;</span>

<span class="sd">    &gt; len(get_rdkit_descriptors(smiles=[&quot;c1ccccc1C&quot;], return_df=True).columns)</span>
<span class="sd">    210</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Making RDKit descriptors for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> molecules&quot;</span><span class="p">)</span>

    <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">CalcMolDescriptors</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">)</span> <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="c1"># make the order consistent sort on the keys in the dictionary important for the numpy return</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">fps</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">fps_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;rdkit_descriptor_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fps_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.get_t5_smiles_rep">
    <p>def <span class="ident">get_t5_smiles_rep</span>(</p><p>model_name: str = &#39;laituan245/molt5-large-smiles2caption&#39;, data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, return_df: bool = False, return_np: bool = False, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate the T5 embedding representations from smiles using a transformer model. We use the Apache - 2.0 licened model (accessed 7/10/24)
from laituan245/molt5-large-smiles2caption https://huggingface.co/laituan245/molt5-large-smiles2caption. This function calls get_nlp_smiles_rep using this model.</p>
<p>Args:
    model_name (str): the model name to use,
    model_type (str): The model type to use i.e. bert, roberta or gpt2.
    data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
     If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
    smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
    smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
    return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
    return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.
    combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is "mean"</p>
<p>Raises:
    RuntimeError: If incompatible inputs are given</p>
<p>Returns:
    Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.get_t5_smiles_rep', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.get_t5_smiles_rep" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_t5_smiles_rep</span><span class="p">(</span>
    <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;laituan245/molt5-large-smiles2caption&quot;</span><span class="p">,</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate the T5 embedding representations from smiles using a transformer model. We use the Apache - 2.0 licened model (accessed 7/10/24)</span>
<span class="sd">    from laituan245/molt5-large-smiles2caption https://huggingface.co/laituan245/molt5-large-smiles2caption. This function calls get_nlp_smiles_rep using this model.</span>

<span class="sd">    Args:</span>
<span class="sd">        model_name (str): the model name to use,</span>
<span class="sd">        model_type (str): The model type to use i.e. bert, roberta or gpt2.</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>
<span class="sd">        combine_strategy (Union[str, int]): How to combine word vectors (one of None, concat, mean or and int to get the embedding for a specific word) . Default is &quot;mean&quot;</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[dict], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">embedding_rep</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span>
        <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
        <span class="n">data_df</span><span class="o">=</span><span class="n">data_df</span><span class="p">,</span>
        <span class="n">smiles_column</span><span class="o">=</span><span class="n">smiles_column</span><span class="p">,</span>
        <span class="n">smiles</span><span class="o">=</span><span class="n">smiles</span><span class="p">,</span>
        <span class="n">return_df</span><span class="o">=</span><span class="n">return_df</span><span class="p">,</span>
        <span class="n">return_np</span><span class="o">=</span><span class="n">return_np</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">embedding_rep</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.list_of_bitvects_to_list_of_lists">
    <p>def <span class="ident">list_of_bitvects_to_list_of_lists</span>(</p><p>bvs: List[rdkit.DataStructs.cDataStructs.ExplicitBitVect])</p>
    </div>




    <div class="desc"><p>Function to convert list of explicit bitvects from RDKit to list of lists. Note that at the time of writing RDKit has functions to do this one at a time but not in batches.</p>
<p>Args:
    bvs (List[cDataStructs.ExplicitBitVect]): List of bitvects from RDKit</p>
<p>Returns:
   List[List[int]]: list of lists of integer binary values</p>
<p>Doctest:</p>
<blockquote>
<p>list_of_bitvects_to_list_of_lists([cDataStructs.CreateFromBitString("1011")]) # doctest: +NORMALIZE_WHITESPACE
[[1, 0, 1, 1]]</p>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.list_of_bitvects_to_list_of_lists', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.list_of_bitvects_to_list_of_lists" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">list_of_bitvects_to_list_of_lists</span><span class="p">(</span>
    <span class="n">bvs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to convert list of explicit bitvects from RDKit to list of lists. Note that at the time of writing RDKit has functions to do this one at a time but not in batches.</span>

<span class="sd">    Args:</span>
<span class="sd">        bvs (List[cDataStructs.ExplicitBitVect]): List of bitvects from RDKit</span>

<span class="sd">    Returns:</span>
<span class="sd">       List[List[int]]: list of lists of integer binary values</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; list_of_bitvects_to_list_of_lists([cDataStructs.CreateFromBitString(&quot;1011&quot;)]) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    [[1, 0, 1, 1]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">ToBitString</span><span class="p">())]</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">bvs</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.list_of_bitvects_to_numpy_arrays">
    <p>def <span class="ident">list_of_bitvects_to_numpy_arrays</span>(</p><p>bvs: List[rdkit.DataStructs.cDataStructs.ExplicitBitVect])</p>
    </div>




    <div class="desc"><p>Function to convert list of explicit bitvectirs from RDKit to numpy arrays. Note that at the time of writing RDKit has functions to do this one at a time but not in batches.</p>
<p>Args:
    bvs (List[cDataStructs.ExplicitBitVect]): List of bitvects from RDKit</p>
<p>Returns:
    np.ndarray: Numpy array of the bit vector arrays</p>
<p>Doctest:</p>
<blockquote>
<p>list_of_bitvects_to_numpy_arrays([cDataStructs.CreateFromBitString("1011")]) # doctest: +NORMALIZE_WHITESPACE
array([[1, 0, 1, 1]], dtype=uint8)</p>
</blockquote></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.list_of_bitvects_to_numpy_arrays', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.list_of_bitvects_to_numpy_arrays" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">list_of_bitvects_to_numpy_arrays</span><span class="p">(</span>
    <span class="n">bvs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to convert list of explicit bitvectirs from RDKit to numpy arrays. Note that at the time of writing RDKit has functions to do this one at a time but not in batches.</span>

<span class="sd">    Args:</span>
<span class="sd">        bvs (List[cDataStructs.ExplicitBitVect]): List of bitvects from RDKit</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Numpy array of the bit vector arrays</span>

<span class="sd">    Doctest:</span>
<span class="sd">    &gt; list_of_bitvects_to_numpy_arrays([cDataStructs.CreateFromBitString(&quot;1011&quot;)]) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    array([[1, 0, 1, 1]], dtype=uint8)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">ToBitString</span><span class="p">())]</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">bvs</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.validate_smile">
    <p>def <span class="ident">validate_smile</span>(</p><p>smile: str, canonicalize: bool = True)</p>
    </div>




    <div class="desc"><p>Function to validate a single smiles string. This differs from get_valid_smiles as
it operates on a single smiles string and garuntees a return as if the smiles is invalid it returns None.</p>
<p>Args:
    smile (str): smiles string to check if it is valid
    canaonicalize (bool): whether to return the input smiles or a canonicalized version for a valid smiles string</p>
<p>Returns:
    Union[None, str]: None for a invalid smiles string and a smiles string for a valid one</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.validate_smile', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.validate_smile" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">validate_smile</span><span class="p">(</span><span class="n">smile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">canonicalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to validate a single smiles string. This differs from get_valid_smiles as</span>
<span class="sd">    it operates on a single smiles string and garuntees a return as if the smiles is invalid it returns None.</span>

<span class="sd">    Args:</span>
<span class="sd">        smile (str): smiles string to check if it is valid</span>
<span class="sd">        canaonicalize (bool): whether to return the input smiles or a canonicalized version for a valid smiles string</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[None, str]: None for a invalid smiles string and a smiles string for a valid one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smile</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Exception when converting smiles to RDKit molecule object&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SMILES string: </span><span class="si">{</span><span class="n">smile</span><span class="si">}</span><span class="s2"> is invalid in RDKit and will be skipped&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">canonicalize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">smile</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.validate_smiles">
    <p>def <span class="ident">validate_smiles</span>(</p><p>smiles: List[str], return_failed_as_None: bool = True, canonicalize: bool = True)</p>
    </div>




    <div class="desc"><p>Function to validate a list of m smiles strings. This differs from get_valid_smiles as
it can guarntee a return, if return_failed_as_None is True (defualt), as if the smiles
is invalid it returns None.</p>
<p>Args:
    smile (str): smiles string to check if it is valid
    return_failed_as_None (bool): whether to return None if the smiles string is invalid
    canaonicalize (bool): whether to return the input smiles or a canonicalized version for a valid smiles string</p>
<p>Returns:
    List[Union[None, str]]: None for a invalid smiles string and a smiles string for a valid one</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.validate_smiles', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.validate_smiles" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">validate_smiles</span><span class="p">(</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">return_failed_as_None</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">canonicalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to validate a list of m smiles strings. This differs from get_valid_smiles as</span>
<span class="sd">    it can guarntee a return, if return_failed_as_None is True (defualt), as if the smiles</span>
<span class="sd">    is invalid it returns None.</span>

<span class="sd">    Args:</span>
<span class="sd">        smile (str): smiles string to check if it is valid</span>
<span class="sd">        return_failed_as_None (bool): whether to return None if the smiles string is invalid</span>
<span class="sd">        canaonicalize (bool): whether to return the input smiles or a canonicalized version for a valid smiles string</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[Union[None, str]]: None for a invalid smiles string and a smiles string for a valid one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">return_failed_as_None</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">validate_smile</span><span class="p">(</span><span class="n">smile</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="n">canonicalize</span><span class="p">)</span> <span class="k">for</span> <span class="n">smile</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">validate_smile</span><span class="p">(</span><span class="n">smile</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="n">canonicalize</span><span class="p">)</span> <span class="k">for</span> <span class="n">smile</span> <span class="ow">in</span> <span class="n">smiles</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ent</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.validate_smiles_and_get_ecfp">
    <p>def <span class="ident">validate_smiles_and_get_ecfp</span>(</p><p>data_df: Optional[pandas.core.frame.DataFrame] = None, smiles_column: Optional[str] = None, smiles: Optional[List[str]] = None, radius: int = 2, hash_length: int = 2048, return_df: bool = False, return_np: bool = False, **kwargs)</p>
    </div>




    <div class="desc"><p>Function to generate ECFP representations from smiles</p>
<p>Args:
    data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.
     If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.
    smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.
    smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.
    radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.
    hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.
    return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.
    return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</p>
<p>Raises:
    RuntimeError: If incompatible inputs are given</p>
<p>Returns:
    Union[List[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</p>
<p>Example:</p>
<pre><code class="language-python">&gt; validate_smiles_and_get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
[&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]

&gt; validate_smiles_and_get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
array([[0, 0, 0, ..., 0, 0, 0]], dtype=uint8)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.validate_smiles_and_get_ecfp', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.validate_smiles_and_get_ecfp" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">validate_smiles_and_get_ecfp</span><span class="p">(</span>
    <span class="n">data_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">hash_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="n">return_df</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">cDataStructs</span><span class="o">.</span><span class="n">ExplicitBitVect</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to generate ECFP representations from smiles</span>

<span class="sd">    Args:</span>
<span class="sd">        data_df (Optional[pd.DataFrame], optional): Dataframe containing at least the smiles strings to use.</span>
<span class="sd">         If this is passed and return_df is true the fingerprints are concatenated to a copy of the input dataframe and returned. Defaults to None.</span>
<span class="sd">        smiles_column (Optional[str], optional): Needed if data_df is given to define which column to find the smiles strings. Defaults to None.</span>
<span class="sd">        smiles (Optional[list[str]], optional): A list of smiles strings to generate fingerprints for. Defaults to None.</span>
<span class="sd">        radius (int, optional): ECFP/Morgan radius, NOTE: ECFPX the X is the diamater i.e. radius*2 therefore ECFP4 means setting this value to 2. Defaults to 2.</span>
<span class="sd">        hash_length (int, optional): The length in number of vector elements of the fingerprint. Defaults to 2048.</span>
<span class="sd">        return_df (bool): Whether to return a pandas dataframe rather than a list of bit vectors. Defaults to False.</span>
<span class="sd">        return_np (bool): Whether to return a numpy array rather than a list of bit vectors. Defalts to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If incompatible inputs are given</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[cDataStructs.ExplicitBitVect], pd.DataFrame, np.ndarray]: Depends on the return type asked for</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt; validate_smiles_and_get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    [&lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at ...&gt;]</span>

<span class="sd">    &gt; validate_smiles_and_get_ecfp(smiles=[&quot;c1ccccc1C&quot;], hash_length=1024, return_np=True) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">    array([[0, 0, 0, ..., 0, 0, 0]], dtype=uint8)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">return_df</span><span class="p">,</span> <span class="n">return_np</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;WARNING - Multiple optional output formats set please set only one of return_df [set as </span><span class="si">{</span><span class="n">return_df</span><span class="si">}</span><span class="s2">] and return_np [</span><span class="si">{</span><span class="n">return_np</span><span class="si">}</span><span class="s2">] to True will return pandas dataframe only.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data_df</span><span class="p">,</span> <span class="n">smiles_column</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">input_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">validate_smiles</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">smiles_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ECFP_smiles_standardized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">smiles</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ECFP_smiles_standardized&quot;</span><span class="p">])</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ECFP_smiles_standardized&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">input_n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">100.0</span><span class="si">}</span><span class="s2">% (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">input_n</span><span class="si">}</span><span class="s2">) of the input smiles were successfully read&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;ERROR - neither smiles nor df together with smiles column were given. One of these must be given as input&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">data_df</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">validate_smiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">return_failed_as_None</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">input_n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">100.0</span><span class="si">}</span><span class="s2">% of the input smiles were successfully read&quot;</span>
        <span class="p">)</span>

    <span class="n">fp_gen</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMorganGenerator</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">fpSize</span><span class="o">=</span><span class="n">hash_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprintAsNumPy</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">smi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fps_np</span>

    <span class="k">elif</span> <span class="n">return_df</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">return_np</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">fps_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprintAsNumPy</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">smi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span>
            <span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;ecfp_bit_</span><span class="si">{</span><span class="n">ith</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ith</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hash_length</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">fps_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">fp_gen</span><span class="o">.</span><span class="n">GetFingerprint</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smi</span><span class="p">))</span> <span class="k">if</span> <span class="n">smi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">smi</span> <span class="ow">in</span> <span class="n">smiles</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>


    <h2 class="section-title" id="header-classes">Classes</h2>

      <div class="item">
      <p id="redxregressors.ml_featurization.CECFPConverter" class="name">class <span class="ident">CECFPConverter</span></p>


    <div class="desc"><p>This is a pipeline module class for converting SMILES strings to count ECFP fingerprints. It can be directly built into a sklearn pipeline.
For example:
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from redxregressors import featurization
model = Pipeline([('smiles_converter', featurization.CECFPConverter()), ('scaler', StandardScaler()), ('RF', RandomForestClassifier())])</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="/sklearn.base.BaseEstimator.ext">sklearn.base.BaseEstimator</a></li>
          <li><a href="/sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin.ext">sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin</a></li>
          <li><a href="/sklearn.utils._metadata_requests._MetadataRequester.ext">sklearn.utils._metadata_requests._MetadataRequester</a></li>
          <li><a href="/sklearn.base.TransformerMixin.ext">sklearn.base.TransformerMixin</a></li>
          <li><a href="/sklearn.utils._set_output._SetOutputMixin.ext">sklearn.utils._set_output._SetOutputMixin</a></li>
          </ul>
          <h3>Methods</h3>

  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.CECFPConverter.fit">
    <p>def <span class="ident">fit</span>(</p><p>self, X, y=None)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.CECFPConverter.fit', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.CECFPConverter.fit" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.CECFPConverter.fit_transform">
    <p>def <span class="ident">fit_transform</span>(</p><p>self, X, y=None, **fit_params)</p>
    </div>




    <div class="desc"><p>Fit to data, then transform it.</p>
<p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code>
and returns a transformed version of <code>X</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>X : array-like of shape (n_samples, n_features)
    Input samples.</p>
<p>y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None
    Target values (None for unsupervised transformations).</p>
<p>**fit_params : dict
    Additional fit parameters.</p>
<h2 id="returns">Returns</h2>
<p>X_new : ndarray array of shape (n_samples, n_features_new)
    Transformed array.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.CECFPConverter.fit_transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.CECFPConverter.fit_transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit to data, then transform it.</span>
<span class="sd">    Fits transformer to `X` and `y` with optional parameters `fit_params`</span>
<span class="sd">    and returns a transformed version of `X`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like of shape (n_samples, n_features)</span>
<span class="sd">        Input samples.</span>
<span class="sd">    y :  array-like of shape (n_samples,) or (n_samples, n_outputs), \</span>
<span class="sd">            default=None</span>
<span class="sd">        Target values (None for unsupervised transformations).</span>
<span class="sd">    **fit_params : dict</span>
<span class="sd">        Additional fit parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_new : ndarray array of shape (n_samples, n_features_new)</span>
<span class="sd">        Transformed array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># non-optimized default implementation; override when a better</span>
    <span class="c1"># method is possible for a given clustering algorithm</span>
    <span class="c1"># we do not route parameters here, since consumers don&#39;t route. But</span>
    <span class="c1"># since it&#39;s possible for a `transform` method to also consume</span>
    <span class="c1"># metadata, we check if that&#39;s the case, and we raise a warning telling</span>
    <span class="c1"># users that they should implement a custom `fit_transform` method</span>
    <span class="c1"># to forward metadata to `transform` as well.</span>
    <span class="c1">#</span>
    <span class="c1"># For that, we calculate routing and check if anything would be routed</span>
    <span class="c1"># to `transform` if we were to route them.</span>
    <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
        <span class="n">transform_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_routing</span><span class="p">()</span><span class="o">.</span><span class="n">consumes</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">fit_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">transform_params</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;This object (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">) has a `transform`&quot;</span>
                    <span class="s2">&quot; method which consumes metadata, but `fit_transform` does not&quot;</span>
                    <span class="s2">&quot; forward metadata to `transform`. Please implement a custom&quot;</span>
                    <span class="s2">&quot; `fit_transform` method to forward metadata to `transform` as&quot;</span>
                    <span class="s2">&quot; well. Alternatively, you can explicitly do&quot;</span>
                    <span class="s2">&quot; `set_transform_request`and set all values to `False` to&quot;</span>
                    <span class="s2">&quot; disable metadata routed to `transform`, if that&#39;s an option.&quot;</span>
                <span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fit method of arity 1 (unsupervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fit method of arity 2 (supervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.CECFPConverter.get_metadata_routing">
    <p>def <span class="ident">get_metadata_routing</span>(</p><p>self)</p>
    </div>




    <div class="desc"><p>Get metadata routing of this object.</p>
<p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing
mechanism works.</p>
<h2 id="returns">Returns</h2>
<p>routing : MetadataRequest
    A :class:<code>~sklearn.utils.metadata_routing.MetadataRequest</code> encapsulating
    routing information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.CECFPConverter.get_metadata_routing', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.CECFPConverter.get_metadata_routing" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>
<span class="sd">    Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">    mechanism works.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    routing : MetadataRequest</span>
<span class="sd">        A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating</span>
<span class="sd">        routing information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata_request</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.CECFPConverter.get_params">
    <p>def <span class="ident">get_params</span>(</p><p>self, deep=True)</p>
    </div>




    <div class="desc"><p>Get parameters for this estimator.</p>
<h2 id="parameters">Parameters</h2>
<p>deep : bool, default=True
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</p>
<h2 id="returns">Returns</h2>
<p>params : dict
    Parameter names mapped to their values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.CECFPConverter.get_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.CECFPConverter.get_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get parameters for this estimator.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    deep : bool, default=True</span>
<span class="sd">        If True, will return the parameters for this estimator and</span>
<span class="sd">        contained subobjects that are estimators.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Parameter names mapped to their values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">():</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;get_params&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">deep_items</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">deep_items</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.CECFPConverter.set_output">
    <p>def <span class="ident">set_output</span>(</p><p>self, *, transform=None)</p>
    </div>




    <div class="desc"><p>Set output container.</p>
<p>See :ref:<code>sphx_glr_auto_examples_miscellaneous_plot_set_output.py</code>
for an example on how to use the API.</p>
<h2 id="parameters">Parameters</h2>
<p>transform : {"default", "pandas", "polars"}, default=None
    Configure output of <code>transform</code> and <code>fit_transform</code>.</p>
<pre><code>- `"default"`: Default output format of a transformer
- `"pandas"`: DataFrame output
- `"polars"`: Polars output
- `None`: Transform configuration is unchanged

.. versionadded:: 1.4
    `"polars"` option was added.
</code></pre>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.CECFPConverter.set_output', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.CECFPConverter.set_output" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@available_if</span><span class="p">(</span><span class="n">_auto_wrap_is_configured</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set output container.</span>
<span class="sd">    See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`</span>
<span class="sd">    for an example on how to use the API.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None</span>
<span class="sd">        Configure output of `transform` and `fit_transform`.</span>
<span class="sd">        - `&quot;default&quot;`: Default output format of a transformer</span>
<span class="sd">        - `&quot;pandas&quot;`: DataFrame output</span>
<span class="sd">        - `&quot;polars&quot;`: Polars output</span>
<span class="sd">        - `None`: Transform configuration is unchanged</span>
<span class="sd">        .. versionadded:: 1.4</span>
<span class="sd">            `&quot;polars&quot;` option was added.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sklearn_output_config&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.CECFPConverter.set_params">
    <p>def <span class="ident">set_params</span>(</p><p>self, **params)</p>
    </div>




    <div class="desc"><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have
parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's
possible to update each component of a nested object.</p>
<h2 id="parameters">Parameters</h2>
<p>**params : dict
    Estimator parameters.</p>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.CECFPConverter.set_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.CECFPConverter.set_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the parameters of this estimator.</span>
<span class="sd">    The method works on simple estimators as well as on nested objects</span>
<span class="sd">    (such as :class:`~sklearn.pipeline.Pipeline`). The latter have</span>
<span class="sd">    parameters of the form ``&lt;component&gt;__&lt;parameter&gt;`` so that it&#39;s</span>
<span class="sd">    possible to update each component of a nested object.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    **params : dict</span>
<span class="sd">        Estimator parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="c1"># Simple optimization to gain speed (inspect is slow)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nested_params</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># grouped by prefix</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">delim</span><span class="p">,</span> <span class="n">sub_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_params</span><span class="p">:</span>
            <span class="n">local_valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid parameter </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> for estimator </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid parameters are: </span><span class="si">{</span><span class="n">local_valid_params</span><span class="si">!r}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">delim</span><span class="p">:</span>
            <span class="n">nested_params</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sub_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub_params</span> <span class="ow">in</span> <span class="n">nested_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">sub_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.CECFPConverter.transform">
    <p>def <span class="ident">transform</span>(</p><p>self, X)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.CECFPConverter.transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.CECFPConverter.transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to CECFP representations .....&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_count_ecfp</span><span class="p">(</span>
            <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
            <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_count_ecfp</span><span class="p">(</span>
            <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span>
            <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>

      </div>
      </div>

      <div class="item">
      <p id="redxregressors.ml_featurization.ECFPConverter" class="name">class <span class="ident">ECFPConverter</span></p>


    <div class="desc"><p>This is a pipeline module class for converting SMILES strings to ECFP fingerprints. It can be directly built into a sklearn pipeline.
For example:
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from redxregressors import featurization
model = Pipeline([('smiles_converter', featurization.ECFPConverter()), ('RF', RandomForestClassifier())])</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="/sklearn.base.BaseEstimator.ext">sklearn.base.BaseEstimator</a></li>
          <li><a href="/sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin.ext">sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin</a></li>
          <li><a href="/sklearn.utils._metadata_requests._MetadataRequester.ext">sklearn.utils._metadata_requests._MetadataRequester</a></li>
          <li><a href="/sklearn.base.TransformerMixin.ext">sklearn.base.TransformerMixin</a></li>
          <li><a href="/sklearn.utils._set_output._SetOutputMixin.ext">sklearn.utils._set_output._SetOutputMixin</a></li>
          </ul>
          <h3>Methods</h3>

  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.ECFPConverter.fit">
    <p>def <span class="ident">fit</span>(</p><p>self, X, y=None)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.ECFPConverter.fit', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.ECFPConverter.fit" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.ECFPConverter.fit_transform">
    <p>def <span class="ident">fit_transform</span>(</p><p>self, X, y=None, **fit_params)</p>
    </div>




    <div class="desc"><p>Fit to data, then transform it.</p>
<p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code>
and returns a transformed version of <code>X</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>X : array-like of shape (n_samples, n_features)
    Input samples.</p>
<p>y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None
    Target values (None for unsupervised transformations).</p>
<p>**fit_params : dict
    Additional fit parameters.</p>
<h2 id="returns">Returns</h2>
<p>X_new : ndarray array of shape (n_samples, n_features_new)
    Transformed array.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.ECFPConverter.fit_transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.ECFPConverter.fit_transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit to data, then transform it.</span>
<span class="sd">    Fits transformer to `X` and `y` with optional parameters `fit_params`</span>
<span class="sd">    and returns a transformed version of `X`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like of shape (n_samples, n_features)</span>
<span class="sd">        Input samples.</span>
<span class="sd">    y :  array-like of shape (n_samples,) or (n_samples, n_outputs), \</span>
<span class="sd">            default=None</span>
<span class="sd">        Target values (None for unsupervised transformations).</span>
<span class="sd">    **fit_params : dict</span>
<span class="sd">        Additional fit parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_new : ndarray array of shape (n_samples, n_features_new)</span>
<span class="sd">        Transformed array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># non-optimized default implementation; override when a better</span>
    <span class="c1"># method is possible for a given clustering algorithm</span>
    <span class="c1"># we do not route parameters here, since consumers don&#39;t route. But</span>
    <span class="c1"># since it&#39;s possible for a `transform` method to also consume</span>
    <span class="c1"># metadata, we check if that&#39;s the case, and we raise a warning telling</span>
    <span class="c1"># users that they should implement a custom `fit_transform` method</span>
    <span class="c1"># to forward metadata to `transform` as well.</span>
    <span class="c1">#</span>
    <span class="c1"># For that, we calculate routing and check if anything would be routed</span>
    <span class="c1"># to `transform` if we were to route them.</span>
    <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
        <span class="n">transform_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_routing</span><span class="p">()</span><span class="o">.</span><span class="n">consumes</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">fit_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">transform_params</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;This object (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">) has a `transform`&quot;</span>
                    <span class="s2">&quot; method which consumes metadata, but `fit_transform` does not&quot;</span>
                    <span class="s2">&quot; forward metadata to `transform`. Please implement a custom&quot;</span>
                    <span class="s2">&quot; `fit_transform` method to forward metadata to `transform` as&quot;</span>
                    <span class="s2">&quot; well. Alternatively, you can explicitly do&quot;</span>
                    <span class="s2">&quot; `set_transform_request`and set all values to `False` to&quot;</span>
                    <span class="s2">&quot; disable metadata routed to `transform`, if that&#39;s an option.&quot;</span>
                <span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fit method of arity 1 (unsupervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fit method of arity 2 (supervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.ECFPConverter.get_metadata_routing">
    <p>def <span class="ident">get_metadata_routing</span>(</p><p>self)</p>
    </div>




    <div class="desc"><p>Get metadata routing of this object.</p>
<p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing
mechanism works.</p>
<h2 id="returns">Returns</h2>
<p>routing : MetadataRequest
    A :class:<code>~sklearn.utils.metadata_routing.MetadataRequest</code> encapsulating
    routing information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.ECFPConverter.get_metadata_routing', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.ECFPConverter.get_metadata_routing" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>
<span class="sd">    Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">    mechanism works.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    routing : MetadataRequest</span>
<span class="sd">        A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating</span>
<span class="sd">        routing information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata_request</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.ECFPConverter.get_params">
    <p>def <span class="ident">get_params</span>(</p><p>self, deep=True)</p>
    </div>




    <div class="desc"><p>Get parameters for this estimator.</p>
<h2 id="parameters">Parameters</h2>
<p>deep : bool, default=True
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</p>
<h2 id="returns">Returns</h2>
<p>params : dict
    Parameter names mapped to their values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.ECFPConverter.get_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.ECFPConverter.get_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get parameters for this estimator.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    deep : bool, default=True</span>
<span class="sd">        If True, will return the parameters for this estimator and</span>
<span class="sd">        contained subobjects that are estimators.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Parameter names mapped to their values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">():</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;get_params&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">deep_items</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">deep_items</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.ECFPConverter.set_output">
    <p>def <span class="ident">set_output</span>(</p><p>self, *, transform=None)</p>
    </div>




    <div class="desc"><p>Set output container.</p>
<p>See :ref:<code>sphx_glr_auto_examples_miscellaneous_plot_set_output.py</code>
for an example on how to use the API.</p>
<h2 id="parameters">Parameters</h2>
<p>transform : {"default", "pandas", "polars"}, default=None
    Configure output of <code>transform</code> and <code>fit_transform</code>.</p>
<pre><code>- `"default"`: Default output format of a transformer
- `"pandas"`: DataFrame output
- `"polars"`: Polars output
- `None`: Transform configuration is unchanged

.. versionadded:: 1.4
    `"polars"` option was added.
</code></pre>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.ECFPConverter.set_output', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.ECFPConverter.set_output" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@available_if</span><span class="p">(</span><span class="n">_auto_wrap_is_configured</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set output container.</span>
<span class="sd">    See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`</span>
<span class="sd">    for an example on how to use the API.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None</span>
<span class="sd">        Configure output of `transform` and `fit_transform`.</span>
<span class="sd">        - `&quot;default&quot;`: Default output format of a transformer</span>
<span class="sd">        - `&quot;pandas&quot;`: DataFrame output</span>
<span class="sd">        - `&quot;polars&quot;`: Polars output</span>
<span class="sd">        - `None`: Transform configuration is unchanged</span>
<span class="sd">        .. versionadded:: 1.4</span>
<span class="sd">            `&quot;polars&quot;` option was added.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sklearn_output_config&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.ECFPConverter.set_params">
    <p>def <span class="ident">set_params</span>(</p><p>self, **params)</p>
    </div>




    <div class="desc"><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have
parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's
possible to update each component of a nested object.</p>
<h2 id="parameters">Parameters</h2>
<p>**params : dict
    Estimator parameters.</p>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.ECFPConverter.set_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.ECFPConverter.set_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the parameters of this estimator.</span>
<span class="sd">    The method works on simple estimators as well as on nested objects</span>
<span class="sd">    (such as :class:`~sklearn.pipeline.Pipeline`). The latter have</span>
<span class="sd">    parameters of the form ``&lt;component&gt;__&lt;parameter&gt;`` so that it&#39;s</span>
<span class="sd">    possible to update each component of a nested object.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    **params : dict</span>
<span class="sd">        Estimator parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="c1"># Simple optimization to gain speed (inspect is slow)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nested_params</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># grouped by prefix</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">delim</span><span class="p">,</span> <span class="n">sub_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_params</span><span class="p">:</span>
            <span class="n">local_valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid parameter </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> for estimator </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid parameters are: </span><span class="si">{</span><span class="n">local_valid_params</span><span class="si">!r}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">delim</span><span class="p">:</span>
            <span class="n">nested_params</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sub_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub_params</span> <span class="ow">in</span> <span class="n">nested_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">sub_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.ECFPConverter.transform">
    <p>def <span class="ident">transform</span>(</p><p>self, X)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.ECFPConverter.transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.ECFPConverter.transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to ECFP representations .....&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_ecfp</span><span class="p">(</span>
            <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
            <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_ecfp</span><span class="p">(</span>
            <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span>
            <span class="n">hash_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_length</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>

      </div>
      </div>

      <div class="item">
      <p id="redxregressors.ml_featurization.GCN_featurize" class="name">class <span class="ident">GCN_featurize</span></p>


    <div class="desc"><p>Class to featurize molecules for use with a GCN model.</p></div>
  <div class="source_cont">
</div>


      <div class="class">
      </div>
      </div>

      <div class="item">
      <p id="redxregressors.ml_featurization.GetAttentiveFPFeatures" class="name">class <span class="ident">GetAttentiveFPFeatures</span></p>


    <div class="desc"><p>Class for making the attentiveFP features. Its is based on the paper https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b00959 and the PyTorch Geometric documentation
https://github.com/pyg-team/pytorch_geometric/blob/master/torch_geometric/datasets/molecule_net.py accessed 21/10/24. The pytorch geometric code is licensed under
the MIT license which is given below.
Copyright (c) 2023 PyG Team <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#116;&#101;&#97;&#109;&#64;&#112;&#121;&#103;&#46;&#111;&#114;&#103;">&#116;&#101;&#97;&#109;&#64;&#112;&#121;&#103;&#46;&#111;&#114;&#103;</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p></div>
  <div class="source_cont">
</div>


      <div class="class">
      </div>
      </div>

      <div class="item">
      <p id="redxregressors.ml_featurization.MACCSConverter" class="name">class <span class="ident">MACCSConverter</span></p>


    <div class="desc"><p>This is a pipeline module class for converting SMILES strings to MACCS fingerprints. It can be directly built into a sklearn pipeline.
For example:
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from redxregressors import featurization
model = Pipeline([('smiles_converter', featurization.MACCSConverter()), ('RF', RandomForestClassifier())])</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="/sklearn.base.BaseEstimator.ext">sklearn.base.BaseEstimator</a></li>
          <li><a href="/sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin.ext">sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin</a></li>
          <li><a href="/sklearn.utils._metadata_requests._MetadataRequester.ext">sklearn.utils._metadata_requests._MetadataRequester</a></li>
          <li><a href="/sklearn.base.TransformerMixin.ext">sklearn.base.TransformerMixin</a></li>
          <li><a href="/sklearn.utils._set_output._SetOutputMixin.ext">sklearn.utils._set_output._SetOutputMixin</a></li>
          </ul>
          <h3>Methods</h3>

  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.MACCSConverter.fit">
    <p>def <span class="ident">fit</span>(</p><p>self, X, y=None)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.MACCSConverter.fit', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.MACCSConverter.fit" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.MACCSConverter.fit_transform">
    <p>def <span class="ident">fit_transform</span>(</p><p>self, X, y=None, **fit_params)</p>
    </div>




    <div class="desc"><p>Fit to data, then transform it.</p>
<p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code>
and returns a transformed version of <code>X</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>X : array-like of shape (n_samples, n_features)
    Input samples.</p>
<p>y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None
    Target values (None for unsupervised transformations).</p>
<p>**fit_params : dict
    Additional fit parameters.</p>
<h2 id="returns">Returns</h2>
<p>X_new : ndarray array of shape (n_samples, n_features_new)
    Transformed array.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.MACCSConverter.fit_transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.MACCSConverter.fit_transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit to data, then transform it.</span>
<span class="sd">    Fits transformer to `X` and `y` with optional parameters `fit_params`</span>
<span class="sd">    and returns a transformed version of `X`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like of shape (n_samples, n_features)</span>
<span class="sd">        Input samples.</span>
<span class="sd">    y :  array-like of shape (n_samples,) or (n_samples, n_outputs), \</span>
<span class="sd">            default=None</span>
<span class="sd">        Target values (None for unsupervised transformations).</span>
<span class="sd">    **fit_params : dict</span>
<span class="sd">        Additional fit parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_new : ndarray array of shape (n_samples, n_features_new)</span>
<span class="sd">        Transformed array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># non-optimized default implementation; override when a better</span>
    <span class="c1"># method is possible for a given clustering algorithm</span>
    <span class="c1"># we do not route parameters here, since consumers don&#39;t route. But</span>
    <span class="c1"># since it&#39;s possible for a `transform` method to also consume</span>
    <span class="c1"># metadata, we check if that&#39;s the case, and we raise a warning telling</span>
    <span class="c1"># users that they should implement a custom `fit_transform` method</span>
    <span class="c1"># to forward metadata to `transform` as well.</span>
    <span class="c1">#</span>
    <span class="c1"># For that, we calculate routing and check if anything would be routed</span>
    <span class="c1"># to `transform` if we were to route them.</span>
    <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
        <span class="n">transform_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_routing</span><span class="p">()</span><span class="o">.</span><span class="n">consumes</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">fit_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">transform_params</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;This object (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">) has a `transform`&quot;</span>
                    <span class="s2">&quot; method which consumes metadata, but `fit_transform` does not&quot;</span>
                    <span class="s2">&quot; forward metadata to `transform`. Please implement a custom&quot;</span>
                    <span class="s2">&quot; `fit_transform` method to forward metadata to `transform` as&quot;</span>
                    <span class="s2">&quot; well. Alternatively, you can explicitly do&quot;</span>
                    <span class="s2">&quot; `set_transform_request`and set all values to `False` to&quot;</span>
                    <span class="s2">&quot; disable metadata routed to `transform`, if that&#39;s an option.&quot;</span>
                <span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fit method of arity 1 (unsupervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fit method of arity 2 (supervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.MACCSConverter.get_metadata_routing">
    <p>def <span class="ident">get_metadata_routing</span>(</p><p>self)</p>
    </div>




    <div class="desc"><p>Get metadata routing of this object.</p>
<p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing
mechanism works.</p>
<h2 id="returns">Returns</h2>
<p>routing : MetadataRequest
    A :class:<code>~sklearn.utils.metadata_routing.MetadataRequest</code> encapsulating
    routing information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.MACCSConverter.get_metadata_routing', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.MACCSConverter.get_metadata_routing" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>
<span class="sd">    Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">    mechanism works.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    routing : MetadataRequest</span>
<span class="sd">        A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating</span>
<span class="sd">        routing information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata_request</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.MACCSConverter.get_params">
    <p>def <span class="ident">get_params</span>(</p><p>self, deep=True)</p>
    </div>




    <div class="desc"><p>Get parameters for this estimator.</p>
<h2 id="parameters">Parameters</h2>
<p>deep : bool, default=True
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</p>
<h2 id="returns">Returns</h2>
<p>params : dict
    Parameter names mapped to their values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.MACCSConverter.get_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.MACCSConverter.get_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get parameters for this estimator.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    deep : bool, default=True</span>
<span class="sd">        If True, will return the parameters for this estimator and</span>
<span class="sd">        contained subobjects that are estimators.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Parameter names mapped to their values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">():</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;get_params&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">deep_items</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">deep_items</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.MACCSConverter.set_output">
    <p>def <span class="ident">set_output</span>(</p><p>self, *, transform=None)</p>
    </div>




    <div class="desc"><p>Set output container.</p>
<p>See :ref:<code>sphx_glr_auto_examples_miscellaneous_plot_set_output.py</code>
for an example on how to use the API.</p>
<h2 id="parameters">Parameters</h2>
<p>transform : {"default", "pandas", "polars"}, default=None
    Configure output of <code>transform</code> and <code>fit_transform</code>.</p>
<pre><code>- `"default"`: Default output format of a transformer
- `"pandas"`: DataFrame output
- `"polars"`: Polars output
- `None`: Transform configuration is unchanged

.. versionadded:: 1.4
    `"polars"` option was added.
</code></pre>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.MACCSConverter.set_output', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.MACCSConverter.set_output" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@available_if</span><span class="p">(</span><span class="n">_auto_wrap_is_configured</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set output container.</span>
<span class="sd">    See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`</span>
<span class="sd">    for an example on how to use the API.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None</span>
<span class="sd">        Configure output of `transform` and `fit_transform`.</span>
<span class="sd">        - `&quot;default&quot;`: Default output format of a transformer</span>
<span class="sd">        - `&quot;pandas&quot;`: DataFrame output</span>
<span class="sd">        - `&quot;polars&quot;`: Polars output</span>
<span class="sd">        - `None`: Transform configuration is unchanged</span>
<span class="sd">        .. versionadded:: 1.4</span>
<span class="sd">            `&quot;polars&quot;` option was added.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sklearn_output_config&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.MACCSConverter.set_params">
    <p>def <span class="ident">set_params</span>(</p><p>self, **params)</p>
    </div>




    <div class="desc"><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have
parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's
possible to update each component of a nested object.</p>
<h2 id="parameters">Parameters</h2>
<p>**params : dict
    Estimator parameters.</p>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.MACCSConverter.set_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.MACCSConverter.set_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the parameters of this estimator.</span>
<span class="sd">    The method works on simple estimators as well as on nested objects</span>
<span class="sd">    (such as :class:`~sklearn.pipeline.Pipeline`). The latter have</span>
<span class="sd">    parameters of the form ``&lt;component&gt;__&lt;parameter&gt;`` so that it&#39;s</span>
<span class="sd">    possible to update each component of a nested object.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    **params : dict</span>
<span class="sd">        Estimator parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="c1"># Simple optimization to gain speed (inspect is slow)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nested_params</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># grouped by prefix</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">delim</span><span class="p">,</span> <span class="n">sub_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_params</span><span class="p">:</span>
            <span class="n">local_valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid parameter </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> for estimator </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid parameters are: </span><span class="si">{</span><span class="n">local_valid_params</span><span class="si">!r}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">delim</span><span class="p">:</span>
            <span class="n">nested_params</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sub_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub_params</span> <span class="ow">in</span> <span class="n">nested_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">sub_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.MACCSConverter.transform">
    <p>def <span class="ident">transform</span>(</p><p>self, X)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.MACCSConverter.transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.MACCSConverter.transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to MACCS representations .....&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_maccs</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_maccs</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>

      </div>
      </div>

      <div class="item">
      <p id="redxregressors.ml_featurization.NLPConverter" class="name">class <span class="ident">NLPConverter</span></p>


    <div class="desc"><p>This is a pipeline module class for converting SMILES strings to sentence embeddings. It can be directly built into a sklearn pipeline.
For example:
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from redxregressors import featurization
model = Pipeline([('smiles_converter', featurization.NLPConverter()), ('scaler', StandardScaler()), ('RF', RandomForestClassifier())])</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="/sklearn.base.BaseEstimator.ext">sklearn.base.BaseEstimator</a></li>
          <li><a href="/sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin.ext">sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin</a></li>
          <li><a href="/sklearn.utils._metadata_requests._MetadataRequester.ext">sklearn.utils._metadata_requests._MetadataRequester</a></li>
          <li><a href="/sklearn.base.TransformerMixin.ext">sklearn.base.TransformerMixin</a></li>
          <li><a href="/sklearn.utils._set_output._SetOutputMixin.ext">sklearn.utils._set_output._SetOutputMixin</a></li>
          </ul>
          <h3>Methods</h3>

  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.NLPConverter.fit">
    <p>def <span class="ident">fit</span>(</p><p>self, X, y=None)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.NLPConverter.fit', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.NLPConverter.fit" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.NLPConverter.fit_transform">
    <p>def <span class="ident">fit_transform</span>(</p><p>self, X, y=None, **fit_params)</p>
    </div>




    <div class="desc"><p>Fit to data, then transform it.</p>
<p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code>
and returns a transformed version of <code>X</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>X : array-like of shape (n_samples, n_features)
    Input samples.</p>
<p>y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None
    Target values (None for unsupervised transformations).</p>
<p>**fit_params : dict
    Additional fit parameters.</p>
<h2 id="returns">Returns</h2>
<p>X_new : ndarray array of shape (n_samples, n_features_new)
    Transformed array.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.NLPConverter.fit_transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.NLPConverter.fit_transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit to data, then transform it.</span>
<span class="sd">    Fits transformer to `X` and `y` with optional parameters `fit_params`</span>
<span class="sd">    and returns a transformed version of `X`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like of shape (n_samples, n_features)</span>
<span class="sd">        Input samples.</span>
<span class="sd">    y :  array-like of shape (n_samples,) or (n_samples, n_outputs), \</span>
<span class="sd">            default=None</span>
<span class="sd">        Target values (None for unsupervised transformations).</span>
<span class="sd">    **fit_params : dict</span>
<span class="sd">        Additional fit parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_new : ndarray array of shape (n_samples, n_features_new)</span>
<span class="sd">        Transformed array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># non-optimized default implementation; override when a better</span>
    <span class="c1"># method is possible for a given clustering algorithm</span>
    <span class="c1"># we do not route parameters here, since consumers don&#39;t route. But</span>
    <span class="c1"># since it&#39;s possible for a `transform` method to also consume</span>
    <span class="c1"># metadata, we check if that&#39;s the case, and we raise a warning telling</span>
    <span class="c1"># users that they should implement a custom `fit_transform` method</span>
    <span class="c1"># to forward metadata to `transform` as well.</span>
    <span class="c1">#</span>
    <span class="c1"># For that, we calculate routing and check if anything would be routed</span>
    <span class="c1"># to `transform` if we were to route them.</span>
    <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
        <span class="n">transform_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_routing</span><span class="p">()</span><span class="o">.</span><span class="n">consumes</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">fit_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">transform_params</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;This object (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">) has a `transform`&quot;</span>
                    <span class="s2">&quot; method which consumes metadata, but `fit_transform` does not&quot;</span>
                    <span class="s2">&quot; forward metadata to `transform`. Please implement a custom&quot;</span>
                    <span class="s2">&quot; `fit_transform` method to forward metadata to `transform` as&quot;</span>
                    <span class="s2">&quot; well. Alternatively, you can explicitly do&quot;</span>
                    <span class="s2">&quot; `set_transform_request`and set all values to `False` to&quot;</span>
                    <span class="s2">&quot; disable metadata routed to `transform`, if that&#39;s an option.&quot;</span>
                <span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fit method of arity 1 (unsupervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fit method of arity 2 (supervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.NLPConverter.get_metadata_routing">
    <p>def <span class="ident">get_metadata_routing</span>(</p><p>self)</p>
    </div>




    <div class="desc"><p>Get metadata routing of this object.</p>
<p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing
mechanism works.</p>
<h2 id="returns">Returns</h2>
<p>routing : MetadataRequest
    A :class:<code>~sklearn.utils.metadata_routing.MetadataRequest</code> encapsulating
    routing information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.NLPConverter.get_metadata_routing', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.NLPConverter.get_metadata_routing" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>
<span class="sd">    Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">    mechanism works.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    routing : MetadataRequest</span>
<span class="sd">        A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating</span>
<span class="sd">        routing information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata_request</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.NLPConverter.get_params">
    <p>def <span class="ident">get_params</span>(</p><p>self, deep=True)</p>
    </div>




    <div class="desc"><p>Get parameters for this estimator.</p>
<h2 id="parameters">Parameters</h2>
<p>deep : bool, default=True
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</p>
<h2 id="returns">Returns</h2>
<p>params : dict
    Parameter names mapped to their values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.NLPConverter.get_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.NLPConverter.get_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get parameters for this estimator.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    deep : bool, default=True</span>
<span class="sd">        If True, will return the parameters for this estimator and</span>
<span class="sd">        contained subobjects that are estimators.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Parameter names mapped to their values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">():</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;get_params&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">deep_items</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">deep_items</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.NLPConverter.set_output">
    <p>def <span class="ident">set_output</span>(</p><p>self, *, transform=None)</p>
    </div>




    <div class="desc"><p>Set output container.</p>
<p>See :ref:<code>sphx_glr_auto_examples_miscellaneous_plot_set_output.py</code>
for an example on how to use the API.</p>
<h2 id="parameters">Parameters</h2>
<p>transform : {"default", "pandas", "polars"}, default=None
    Configure output of <code>transform</code> and <code>fit_transform</code>.</p>
<pre><code>- `"default"`: Default output format of a transformer
- `"pandas"`: DataFrame output
- `"polars"`: Polars output
- `None`: Transform configuration is unchanged

.. versionadded:: 1.4
    `"polars"` option was added.
</code></pre>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.NLPConverter.set_output', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.NLPConverter.set_output" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@available_if</span><span class="p">(</span><span class="n">_auto_wrap_is_configured</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set output container.</span>
<span class="sd">    See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`</span>
<span class="sd">    for an example on how to use the API.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None</span>
<span class="sd">        Configure output of `transform` and `fit_transform`.</span>
<span class="sd">        - `&quot;default&quot;`: Default output format of a transformer</span>
<span class="sd">        - `&quot;pandas&quot;`: DataFrame output</span>
<span class="sd">        - `&quot;polars&quot;`: Polars output</span>
<span class="sd">        - `None`: Transform configuration is unchanged</span>
<span class="sd">        .. versionadded:: 1.4</span>
<span class="sd">            `&quot;polars&quot;` option was added.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sklearn_output_config&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.NLPConverter.set_params">
    <p>def <span class="ident">set_params</span>(</p><p>self, **params)</p>
    </div>




    <div class="desc"><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have
parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's
possible to update each component of a nested object.</p>
<h2 id="parameters">Parameters</h2>
<p>**params : dict
    Estimator parameters.</p>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.NLPConverter.set_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.NLPConverter.set_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the parameters of this estimator.</span>
<span class="sd">    The method works on simple estimators as well as on nested objects</span>
<span class="sd">    (such as :class:`~sklearn.pipeline.Pipeline`). The latter have</span>
<span class="sd">    parameters of the form ``&lt;component&gt;__&lt;parameter&gt;`` so that it&#39;s</span>
<span class="sd">    possible to update each component of a nested object.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    **params : dict</span>
<span class="sd">        Estimator parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="c1"># Simple optimization to gain speed (inspect is slow)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nested_params</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># grouped by prefix</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">delim</span><span class="p">,</span> <span class="n">sub_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_params</span><span class="p">:</span>
            <span class="n">local_valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid parameter </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> for estimator </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid parameters are: </span><span class="si">{</span><span class="n">local_valid_params</span><span class="si">!r}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">delim</span><span class="p">:</span>
            <span class="n">nested_params</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sub_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub_params</span> <span class="ow">in</span> <span class="n">nested_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">sub_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.NLPConverter.transform">
    <p>def <span class="ident">transform</span>(</p><p>self, X)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.NLPConverter.transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.NLPConverter.transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to sentence embeddings .....&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span><span class="n">model_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span> <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">embeddings</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="n">get_nlp_smiles_rep</span><span class="p">(</span>
            <span class="n">model_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span> <span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">embeddings</span>
</pre></div>

  </div>
</div>

  </div>

      </div>
      </div>

      <div class="item">
      <p id="redxregressors.ml_featurization.RDKitDescriptorsConverter" class="name">class <span class="ident">RDKitDescriptorsConverter</span></p>


    <div class="desc"><p>This is a pipeline module class for converting SMILES strings to RDKit descriptors. It can be directly built into a sklearn pipeline.
For example:
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from redxregressors import featurization
model = Pipeline([('smiles_converter', featurization.RDKitDescriptorsConverter()), ('scaler', StandardScaler()), ('RF', RandomForestClassifier())])</p></div>
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="/sklearn.base.BaseEstimator.ext">sklearn.base.BaseEstimator</a></li>
          <li><a href="/sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin.ext">sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin</a></li>
          <li><a href="/sklearn.utils._metadata_requests._MetadataRequester.ext">sklearn.utils._metadata_requests._MetadataRequester</a></li>
          <li><a href="/sklearn.base.TransformerMixin.ext">sklearn.base.TransformerMixin</a></li>
          <li><a href="/sklearn.utils._set_output._SetOutputMixin.ext">sklearn.utils._set_output._SetOutputMixin</a></li>
          </ul>
          <h3>Methods</h3>

  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.RDKitDescriptorsConverter.fit">
    <p>def <span class="ident">fit</span>(</p><p>self, X, y=None)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.RDKitDescriptorsConverter.fit', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.RDKitDescriptorsConverter.fit" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.RDKitDescriptorsConverter.fit_transform">
    <p>def <span class="ident">fit_transform</span>(</p><p>self, X, y=None, **fit_params)</p>
    </div>




    <div class="desc"><p>Fit to data, then transform it.</p>
<p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code>
and returns a transformed version of <code>X</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>X : array-like of shape (n_samples, n_features)
    Input samples.</p>
<p>y :  array-like of shape (n_samples,) or (n_samples, n_outputs),                 default=None
    Target values (None for unsupervised transformations).</p>
<p>**fit_params : dict
    Additional fit parameters.</p>
<h2 id="returns">Returns</h2>
<p>X_new : ndarray array of shape (n_samples, n_features_new)
    Transformed array.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.RDKitDescriptorsConverter.fit_transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.RDKitDescriptorsConverter.fit_transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit to data, then transform it.</span>
<span class="sd">    Fits transformer to `X` and `y` with optional parameters `fit_params`</span>
<span class="sd">    and returns a transformed version of `X`.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like of shape (n_samples, n_features)</span>
<span class="sd">        Input samples.</span>
<span class="sd">    y :  array-like of shape (n_samples,) or (n_samples, n_outputs), \</span>
<span class="sd">            default=None</span>
<span class="sd">        Target values (None for unsupervised transformations).</span>
<span class="sd">    **fit_params : dict</span>
<span class="sd">        Additional fit parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_new : ndarray array of shape (n_samples, n_features_new)</span>
<span class="sd">        Transformed array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># non-optimized default implementation; override when a better</span>
    <span class="c1"># method is possible for a given clustering algorithm</span>
    <span class="c1"># we do not route parameters here, since consumers don&#39;t route. But</span>
    <span class="c1"># since it&#39;s possible for a `transform` method to also consume</span>
    <span class="c1"># metadata, we check if that&#39;s the case, and we raise a warning telling</span>
    <span class="c1"># users that they should implement a custom `fit_transform` method</span>
    <span class="c1"># to forward metadata to `transform` as well.</span>
    <span class="c1">#</span>
    <span class="c1"># For that, we calculate routing and check if anything would be routed</span>
    <span class="c1"># to `transform` if we were to route them.</span>
    <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
        <span class="n">transform_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata_routing</span><span class="p">()</span><span class="o">.</span><span class="n">consumes</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">fit_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">transform_params</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;This object (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">) has a `transform`&quot;</span>
                    <span class="s2">&quot; method which consumes metadata, but `fit_transform` does not&quot;</span>
                    <span class="s2">&quot; forward metadata to `transform`. Please implement a custom&quot;</span>
                    <span class="s2">&quot; `fit_transform` method to forward metadata to `transform` as&quot;</span>
                    <span class="s2">&quot; well. Alternatively, you can explicitly do&quot;</span>
                    <span class="s2">&quot; `set_transform_request`and set all values to `False` to&quot;</span>
                    <span class="s2">&quot; disable metadata routed to `transform`, if that&#39;s an option.&quot;</span>
                <span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fit method of arity 1 (unsupervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fit method of arity 2 (supervised transformation)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.RDKitDescriptorsConverter.get_metadata_routing">
    <p>def <span class="ident">get_metadata_routing</span>(</p><p>self)</p>
    </div>




    <div class="desc"><p>Get metadata routing of this object.</p>
<p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing
mechanism works.</p>
<h2 id="returns">Returns</h2>
<p>routing : MetadataRequest
    A :class:<code>~sklearn.utils.metadata_routing.MetadataRequest</code> encapsulating
    routing information.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.RDKitDescriptorsConverter.get_metadata_routing', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.RDKitDescriptorsConverter.get_metadata_routing" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>
<span class="sd">    Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">    mechanism works.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    routing : MetadataRequest</span>
<span class="sd">        A :class:`~sklearn.utils.metadata_routing.MetadataRequest` encapsulating</span>
<span class="sd">        routing information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_metadata_request</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.RDKitDescriptorsConverter.get_params">
    <p>def <span class="ident">get_params</span>(</p><p>self, deep=True)</p>
    </div>




    <div class="desc"><p>Get parameters for this estimator.</p>
<h2 id="parameters">Parameters</h2>
<p>deep : bool, default=True
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</p>
<h2 id="returns">Returns</h2>
<p>params : dict
    Parameter names mapped to their values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.RDKitDescriptorsConverter.get_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.RDKitDescriptorsConverter.get_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get parameters for this estimator.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    deep : bool, default=True</span>
<span class="sd">        If True, will return the parameters for this estimator and</span>
<span class="sd">        contained subobjects that are estimators.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params : dict</span>
<span class="sd">        Parameter names mapped to their values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">():</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deep</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;get_params&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">deep_items</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">deep_items</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.RDKitDescriptorsConverter.set_output">
    <p>def <span class="ident">set_output</span>(</p><p>self, *, transform=None)</p>
    </div>




    <div class="desc"><p>Set output container.</p>
<p>See :ref:<code>sphx_glr_auto_examples_miscellaneous_plot_set_output.py</code>
for an example on how to use the API.</p>
<h2 id="parameters">Parameters</h2>
<p>transform : {"default", "pandas", "polars"}, default=None
    Configure output of <code>transform</code> and <code>fit_transform</code>.</p>
<pre><code>- `"default"`: Default output format of a transformer
- `"pandas"`: DataFrame output
- `"polars"`: Polars output
- `None`: Transform configuration is unchanged

.. versionadded:: 1.4
    `"polars"` option was added.
</code></pre>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.RDKitDescriptorsConverter.set_output', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.RDKitDescriptorsConverter.set_output" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@available_if</span><span class="p">(</span><span class="n">_auto_wrap_is_configured</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set output container.</span>
<span class="sd">    See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`</span>
<span class="sd">    for an example on how to use the API.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None</span>
<span class="sd">        Configure output of `transform` and `fit_transform`.</span>
<span class="sd">        - `&quot;default&quot;`: Default output format of a transformer</span>
<span class="sd">        - `&quot;pandas&quot;`: DataFrame output</span>
<span class="sd">        - `&quot;polars&quot;`: Polars output</span>
<span class="sd">        - `None`: Transform configuration is unchanged</span>
<span class="sd">        .. versionadded:: 1.4</span>
<span class="sd">            `&quot;polars&quot;` option was added.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_sklearn_output_config&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_sklearn_output_config</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.RDKitDescriptorsConverter.set_params">
    <p>def <span class="ident">set_params</span>(</p><p>self, **params)</p>
    </div>




    <div class="desc"><p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have
parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's
possible to update each component of a nested object.</p>
<h2 id="parameters">Parameters</h2>
<p>**params : dict
    Estimator parameters.</p>
<h2 id="returns">Returns</h2>
<p>self : estimator instance
    Estimator instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.RDKitDescriptorsConverter.set_params', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.RDKitDescriptorsConverter.set_params" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the parameters of this estimator.</span>
<span class="sd">    The method works on simple estimators as well as on nested objects</span>
<span class="sd">    (such as :class:`~sklearn.pipeline.Pipeline`). The latter have</span>
<span class="sd">    parameters of the form ``&lt;component&gt;__&lt;parameter&gt;`` so that it&#39;s</span>
<span class="sd">    possible to update each component of a nested object.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    **params : dict</span>
<span class="sd">        Estimator parameters.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    self : estimator instance</span>
<span class="sd">        Estimator instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="c1"># Simple optimization to gain speed (inspect is slow)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nested_params</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># grouped by prefix</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">delim</span><span class="p">,</span> <span class="n">sub_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_params</span><span class="p">:</span>
            <span class="n">local_valid_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_param_names</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid parameter </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> for estimator </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid parameters are: </span><span class="si">{</span><span class="n">local_valid_params</span><span class="si">!r}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">delim</span><span class="p">:</span>
            <span class="n">nested_params</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sub_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub_params</span> <span class="ow">in</span> <span class="n">nested_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">valid_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="o">**</span><span class="n">sub_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>


  <div class="item">
    <div class="name def" id="redxregressors.ml_featurization.RDKitDescriptorsConverter.transform">
    <p>def <span class="ident">transform</span>(</p><p>self, X)</p>
    </div>




  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redxregressors.ml_featurization.RDKitDescriptorsConverter.transform', this);">Show source &equiv;</a></p>
  <div id="source-redxregressors.ml_featurization.RDKitDescriptorsConverter.transform" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming SMILES data to RDKit descriptors .....&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_rdkit_descriptors</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">get_rdkit_descriptors</span><span class="p">(</span><span class="n">smiles</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smiles_col</span><span class="p">],</span> <span class="n">return_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span>
</pre></div>

  </div>
</div>

  </div>

      </div>
      </div>

  </section>
</article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Generated by <a href="https://github.com/timothycrosley/pdocs">pdocs 1.2.0</a>
    </p>
  </footer>
</div>
</body>
</html>
